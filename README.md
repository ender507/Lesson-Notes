# 数据结构与算法 学习笔记
## Chapter1 Introduction
### 1. 为什么学习数据结构
- 用计算机求解问题的基本步骤：分析问题->设计算法->编写程序->运行程序与验证结果->返回之前3个步骤重复，直至问题解决。

- 计算机科学是一门研究用计算机进行信息表示和处理的科学。设计的两个问题为：信息的表示（存储设计）和信息的处理（算法设计）。二者直接关系到程序的效率。数据结构与算法是研究数值与非数值计算问题中计算机的操作对象以及它们之间的关系和操作的学科，要求我们有分析问题并将问题中的内容抽象为有逻辑结构数据，并设计好数据的物理结构与算法，分析算法的复杂性，最终能够将算法在计算机中实现。

### 2. 相关定义与术语
- 数据Data：被用作描述对象，是一切能输入到计算机中并能被计算机程序识别和出力的符号集合，包括数值数据和非数值数据。
- 数据类型Data Type：包括数值范围和相关操作。
- 数据元素Data Element：数据的基本单位，在程序通常作为一个整体进行考虑和处理
- 数据项Data Item：构成数据元素的最小单位。
- 数据对象Data Object：具有相同性质的数据元素的集合。
  
  例如：数据类型为链表，则数据元素为各个节点，每个节点的数据项有指针、数值等等。
- 逻辑结构：
  - 集合：各个元素确定、互异、无序，同属一个集合，别无其他联系。
  - 线性结构：元素有唯一直接前驱和后继，表现为线性关系
  - 树结构：元素之间存在一对多的层次关系
  - 图结构：元素之间存在多对多的任意关系。任意指结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。 
- 物理结构：数据及其逻辑结构如何储存在计算机中
  - 直接访问：可用于连续设计，数据元素之间的逻辑关系可 以由元素的存储位置来表示 
  - 间接访问：可用于连接设计，数据元素之间的逻辑关系将 由指针进行关联和表示 

- 数据结构Data Structures：包括逻辑结构、物理结构和操作集。

数据的逻辑结构属于用户视图，是面向问题的， 反映了数据内部的构成方式；数据的存储结构属 于具体实现的视图，是面向计算机的。  一种数据的逻辑结构可以用多种存储结构来存储， 而采用不同的存储结构，其数据处理的效率往往 是不同的。 
### 3. 抽象数据类型ADT
ADT的定义仅是一组逻辑特性描述， 与其在计算机内的表示和实现无关。因此，不论ADT的内部结构如何变化，只要其数学特性不变，都不影响其外部使用。

数据类型可以看作是已经实现了的抽象数据类型。如：int型数据：ADT int=( {x |x∈Z}，{+,-,*,/,%, ≦,==} ) 

ADT应包括数据对象、数据关系、基本操作。其中，基本操作应包括初始条件、操作结果。需要指出输入、输出、前置条件（输入满足的条件）和后置条件（输出满足的条件）。

### 4. 算法
算法是使用确定可行的详细步骤处理输入数据，得到输出数据的解决问题的执行方法，具有5个重要特征：
- 确定性：每一种运算必须有确切定义，不能有二义性
- 可行性：可以通过已经实现的基本操作执行有限次来实现
- 输入：算法有**0个或多个**输入，全部取自定义域
- 输出：算法有**1个或多个**输出
- 有限性：算法执行有限步之后能够终止。
 
算法的描述方法：
- 自然语言：容易理解却冗长，有二义性
- 流程图：流程直观，但缺少严密性、灵活性
- 伪代码：表达能力强，抽象性强，易理解
- 程序语言：能直接用计算机执行，但抽象性差

一个优秀的算法要有以下特质：
- 正确性，能够正确解决问题
- 可读性，易于理解
- 健壮性，便于维护和修改
- 效率高，使用较少的计算机资源解决问题，使用较少的时间和空间。故分析算法时需要考虑：
  - 时间复杂性：使用基本操作的语句的执行次数的渐进阶进行评估。
  - 空间复杂性：执行过程中的最大储存量需求。

### 5.设计思路
程序=数据结构+算法。解决问题时，要在分析问题后，确定数据的逻辑结构，设计其物理结构，再确定其操作。先建模后确定算法。接着逐步求精，直至能够实现ADT。

## Chapter2 Linear Structure线性结构
### 1.线性表List
L=(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>),其中a<sub>i</sub>为数据元素，i为位置或序号，n为表长。链表具有以下特征：
- 有限性：链表元素个数有穷
- 向同性：元素类型相同
- 相继性：除了第一个元素a<sub>1</sub>无直接前驱，最后一个元素a<sub>n</sub>无直接后继外，任意一个元素a<sub>i</sub>都有**唯一**直接前驱a<sub>i-1</sub>和直接后继a<sub>i+1</sub>

对表的基本操作有：
1. 求表长len
2. 对某位置的元素进行读写get
3. 按值对元素位置进行查找search
4. 按位置插入insert
5. 按位置或值删除delete

物理结构设计：
- 顺序存储：使用连续地址空间进行存储元素，物理位置的相邻表示逻辑上的相邻。若每个元素站地址空间为c，则地址位置loc(a<sub>i</sub>)=loc(a<sub>i</sub>)+(i-1)*c
  - 优点
    - 结构简单
    - 连续地址空间结构紧凑，存储效率高，不需要为表示逻辑关系而增加额外空间
    - 顺序表是随机存储结构，按位置访问元素的时间是常数时间
  - 缺点
    - 插入删除时需要移动较多元素以保持物理空间的连续性，效率较低
    - 对于长度变化较大的线性表，需要预先分配较大空间或扩充，造成不便
- 链式存储：利用散列在计算机中的存储单元，地址不一定连续。各个单元通过保存储存的地址（指针）来关联。
  - 优点
    - 容量灵活，易扩充
    - 已知位置时，插入和删除元素的时间开销为常数
  - 缺点
    - 需要额外的空间表示逻辑关系
    - 访问元素时间复杂度为O(n)，比较费时间
### 2.栈Stack
限定仅在表尾进行插入和删除操作的线性表叫做栈。不含任何数据元素的栈为空栈，允许插入（入栈、进栈、压栈）和删除（出栈、弹栈） 的一端称为栈顶，另一端称为栈底。这种操作方式称为后进先出（LIFO）。

基本操作：
- 置空clear
- 判断是否为空empty
- 入栈push
- 出栈pop
- 获取栈顶元素top

应用：
1. 进制转换：例如159<sub>10</sub>转化为8进制，将159反复除以8，将每次的余数存入栈，最终依次将各个数出栈即可。其中栈顶为高位数字，栈底为低位数字。
2. 括号匹配：依次遍历表达式字符串，遇到左括号`(`入栈，右括号`)`出栈。若空栈时出栈或遍历完成后栈不为空，则括号不匹配。
3. 中缀表达式求值：准备**数字栈**和**符号栈**。在操作符末尾加入一个`#`
   1. 初始化：符号栈压入`#`
   2. 依次读取表达式中的每个字符
      1. 如果是数字，压入数字栈（不考虑多位数字）
      2. 如果是操作符，将其和符号栈栈顶元素比较优先级：
         1. 栈顶优先级低，元素入栈
         2. 优先级相等，出栈
         3. 栈顶优先级高，取出栈顶操作符，数字栈取出两个数字，运算后的结果存入数字栈，再将现有操作符和栈顶比较（重复4）
   3. 符号栈为空时处理完毕

- 优先级比较：
  - 乘除高于加减。
  - 两个符号都为加减，或者都为乘除，算栈顶元素优先级更低。
  - 除去`#`外，对于栈外元素，`(`优先级最低，`)`最高，栈顶元素相反。除非栈顶为`(`，读取元素为`)`，优先级相同。
  - `#`优先级低于任何元素，且优先级等于自身

4. 中缀表达式转后缀：只须一个符号栈
   1. 符号栈压入`#`
   2. 依次读取字符
      1. 数字直接输出
      2. 符号与栈顶元素比较
         1. 栈顶优先级低，入栈
         2. 相等，出栈不输出
         3. 栈顶优先级高，出栈并输出，重复4
    3. 栈为空时处理完毕

- 优先级比较：两个符号都为加减，或者都为乘除，算栈顶元素优先级更高。

5. 后缀表达式求值（后缀表达式无括号）：只须一个数字栈。依次读取字符，数字入栈，符号则取两个数字运算在存入栈中，直至整个表达式处理完成。 

#### 递归
可用子问题求解，且某一有限步的子问题有直接解的问题可用递归求解。递归基：定义最简单情况的求解，基地柜出口。递归步：将问题化为更简单的子问题的步骤。

应用：
1. 求阶乘：n!=n*(n-1)!,0!=1
2. 斐波那契数列：f(n)=f(n-1)+f(n-2),f(0)=f(1)=1
3. Ackerman函数
4. 多项式求解：p<sub>k</sub>=xp<sub>k-1</sub>+a<sub>n-k</sub>,n=0停止。
5. 全排列问题：先得到一个排列，生成第一个数确定后从第二个数开始的子排列。再将第一个数依次和其他数交换，并重复。只有一个元素时截止。
6. 整数划分：q(n,m)中n表示原数字，m为划分时出现的最大数。q(n,1)=q(1,m)=1。m>=n时q(n,m)=q(n,n)，否则q(n,m)=q(n,m-1)+q(n-m,m)。q(n,n)=1+q(n,n-1)。q(1,1)=1
7. 汉诺塔问题：n个圆盘。n=1时将圆盘从A移动到C，否则将1个从A移动到B，将n-1个移动到C，再将那一个移到C。

### 3.队列Queue
和栈相对，只能在队尾插入，在队首删除，先进先出（FIFO）
使用数组实现队列会出现队列溢出现象，含真溢出（数组全满）和假溢出（数组首部有空余位置）。使用循环队列解决假溢出。循环队列会出现rear==front时可能是队空或队满的歧义。解决方法：
- 增设count，用count==0或者MaxSize判断
- 增设flag判断
- 浪费一个元素空间(rear不存元素)，从0开始存储时，队空为front==rear，队满为((front+1)%MaxSize==rear)，入队：rear=(rear+1)%MaxSize,出队：front=(front+1)%MaxSize

### 4.串String
串是由若干个字符组成的有限序列，0个字符的串为空串。和其他的线性结构相比，特殊的基本操作有：
- 拼接两个串concat
- 求子串substr
- 定位子串index

模式匹配算法：子串定位运算
- 朴素模式匹配算法(Brute-Force算法) ：依次枚举。时间复杂性最好为O(n+m)，最坏为O(n*m)
- KMP算法：设主串为S，模式串为P，创建Next数组表示右移模式串的长度。next的建立实质为找模式串中的最长相同的前缀和后缀。若从1开始存数，有：next[1]=0,next[2]=1,对其他next[i],为之前[0,i-1]子串的首位重合个数+1。若第i个不匹配，模式串的比较位置变为next[i]。
```c++
int GetNext(string str,vector<int>&next){
    int len=str.length();
    next[1] = 0;
    int i = 1,j = 0;
    while(i<=len){
        if(j==0||str[i]==str[j]) next[++i] = ++j;
        else j = next[j];
    }
}
```
next数组的改进算法nextval:
```c++
if (p[i] != p[next[i]]) nextval[i] = next[i];
else nextval[i] = nextval[next[i]];
```
### 5.数组Array和广义表
#### 数组
数组的特点：元素数目固定、下标有界。二维数组的线性存储方式有行有限存储和列有限存储。

用数组可以实现对特殊矩阵的压缩存储：
- 三角矩阵：按先行后列的顺序线性存储。
- 对称矩阵：nxn的矩阵只需要存储n(n＋1)/2个元素，即只保留其上三角或下三角，按先行后列的顺序存储。比如保留下三角，对于第i行第j个元素的访问，若j>i可变为对第j行第i个元素的访问，否则访问第i*(i-1)/2+j-1个元素。
- 稀疏矩阵：大多元素为0的矩阵，考虑三元数组存储，即存储非零位置的行、列、数值。交换行列可以快速完成转置。

有n组数据的三元数组的快速转置算法：（维持数组的行优先存储顺序）
1. 遍历一遍三元数组，把每一列元素的个数求出来，存入数组num[n]
2. 创建数组cpot[n]，cpot[i]表示下一个第i列的数存储到新数组中的位置。cpot的第一个数为1（假设数组从1开始存），往后每一个cpot[i]=cpot[i-1]+num[i-1]。即第i列（新的第i行）的第一个数存在cpot[i]的位置。
3. 遍历原数组。对于原本在第i列的元素，存入新数组的第cpot[i]个。cpot[i]增1。注意交换原
   行和列。
4. 原行优先三元组遍历完成后，得到了转置后的、行优先存储的三元组。
#### 广义表
广义表的基本特征：
- 层次性：广义表的元素可以是子表，子表的元素依旧可以是子表（套娃）
- 共享性：一个广义表可以被多个表共享
- 递归性：广义表可以是自己的子表：E=(a,E)
基本概念：
- 表头：第一个元素（可以是表）
- 表尾：去掉第一个元素，剩下元素组成的表（必须是表）
- 深度：括号的重数。元素不含子表的表深度为1，递归表深度无穷大。
广义表的存储（链式结构）：
- 原子节点：表示原子项（单个元素，不含表）。节点包括标志域（tag，用于和表节点区分）
- 表节点：包括标志域、表头指针、表尾指针。表尾指针必然指向表节点。

## Chapter3 Tree树
