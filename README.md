# 数据结构与算法 学习笔记
## Chapter1 Introduction
### 1. 为什么学习数据结构
- 用计算机求解问题的基本步骤：分析问题->设计算法->编写程序->运行程序与验证结果->返回之前3个步骤重复，直至问题解决。

- 计算机科学是一门研究用计算机进行信息表示和处理的科学。设计的两个问题为：信息的表示（存储设计）和信息的处理（算法设计）。二者直接关系到程序的效率。数据结构与算法是研究数值与非数值计算问题中计算机的操作对象以及它们之间的关系和操作的学科，要求我们有分析问题并将问题中的内容抽象为有逻辑结构数据，并设计好数据的物理结构与算法，分析算法的复杂性，最终能够将算法在计算机中实现。

### 2. 相关定义与术语
- 数据Data：被用作描述对象，是一切能输入到计算机中并能被计算机程序识别和出力的符号集合，包括数值数据和非数值数据。
- 数据类型Data Type：包括数值范围和相关操作。
- 数据元素Data Element：数据的基本单位，在程序通常作为一个整体进行考虑和处理
- 数据项Data Item：构成数据元素的最小单位。
- 数据对象Data Object：具有相同性质的数据元素的集合。
  
  例如：数据类型为链表，则数据元素为各个节点，每个节点的数据项有指针、数值等等。
- 逻辑结构：
  - 集合：各个元素确定、互异、无序，同属一个集合，别无其他联系。
  - 线性结构：元素有唯一直接前驱和后继，表现为线性关系
  - 树结构：元素之间存在一对多的层次关系
  - 图结构：元素之间存在多对多的任意关系。任意指结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。 
- 物理结构：数据及其逻辑结构如何储存在计算机中
  - 直接访问：可用于连续设计，数据元素之间的逻辑关系可 以由元素的存储位置来表示 
  - 间接访问：可用于连接设计，数据元素之间的逻辑关系将 由指针进行关联和表示 

- 数据结构Data Structures：包括逻辑结构、物理结构和操作集。

数据的逻辑结构属于用户视图，是面向问题的， 反映了数据内部的构成方式；数据的存储结构属 于具体实现的视图，是面向计算机的。  一种数据的逻辑结构可以用多种存储结构来存储， 而采用不同的存储结构，其数据处理的效率往往 是不同的。 
### 3. 抽象数据类型ADT
ADT的定义仅是一组逻辑特性描述， 与其在计算机内的表示和实现无关。因此，不论ADT的内部结构如何变化，只要其数学特性不变，都不影响其外部使用。

数据类型可以看作是已经实现了的抽象数据类型。如：int型数据：ADT int=( {x |x∈Z}，{+,-,*,/,%, ≦,==} ) 

ADT应包括数据对象、数据关系、基本操作。其中，基本操作应包括初始条件、操作结果。需要指出输入、输出、前置条件（输入满足的条件）和后置条件（输出满足的条件）。

### 4. 算法
算法是使用确定可行的详细步骤处理输入数据，得到输出数据的解决问题的执行方法，具有5个重要特征：
- 确定性：每一种运算必须有确切定义，不能有二义性
- 可行性：可以通过已经实现的基本操作执行有限次来实现
- 输入：算法有**0个或多个**输入，全部取自定义域
- 输出：算法有**1个或多个**输出
- 有限性：算法执行有限步之后能够终止。
 
算法的描述方法：
- 自然语言：容易理解却冗长，有二义性
- 流程图：流程直观，但缺少严密性、灵活性
- 伪代码：表达能力强，抽象性强，易理解
- 程序语言：能直接用计算机执行，但抽象性差

一个优秀的算法要有以下特质：
- 正确性，能够正确解决问题
- 可读性，易于理解
- 健壮性，便于维护和修改
- 效率高，使用较少的计算机资源解决问题，使用较少的时间和空间。故分析算法时需要考虑：
  - 时间复杂性：使用基本操作的语句的执行次数的渐进阶进行评估。
  - 空间复杂性：执行过程中的最大储存量需求。

### 5.设计思路
程序=数据结构+算法。解决问题时，要在分析问题后，确定数据的逻辑结构，设计其物理结构，再确定其操作。先建模后确定算法。接着逐步求精，直至能够实现ADT。

-----------------------------------------------
## Chapter2 Linear Structure线性结构
### 1.线性表List
L=(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>),其中a<sub>i</sub>为数据元素，i为位置或序号，n为表长。链表具有以下特征：
- 有限性：链表元素个数有穷
- 向同性：元素类型相同
- 相继性：除了第一个元素a<sub>1</sub>无直接前驱，最后一个元素a<sub>n</sub>无直接后继外，任意一个元素a<sub>i</sub>都有**唯一**直接前驱a<sub>i-1</sub>和直接后继a<sub>i+1</sub>

对表的基本操作有：
1. 求表长len
2. 对某位置的元素进行读写get
3. 按值对元素位置进行查找search
4. 按位置插入insert
5. 按位置或值删除delete

物理结构设计：
- 顺序存储：使用连续地址空间进行存储元素，物理位置的相邻表示逻辑上的相邻。若每个元素站地址空间为c，则地址位置loc(a<sub>i</sub>)=loc(a<sub>i</sub>)+(i-1)*c
  - 优点
    - 结构简单
    - 连续地址空间结构紧凑，存储效率高，不需要为表示逻辑关系而增加额外空间
    - 顺序表是随机存储结构，按位置访问元素的时间是常数时间
  - 缺点
    - 插入删除时需要移动较多元素以保持物理空间的连续性，效率较低
    - 对于长度变化较大的线性表，需要预先分配较大空间或扩充，造成不便
- 链式存储：利用散列在计算机中的存储单元，地址不一定连续。各个单元通过保存储存的地址（指针）来关联。
  - 优点
    - 容量灵活，易扩充
    - 已知位置时，插入和删除元素的时间开销为常数
  - 缺点
    - 需要额外的空间表示逻辑关系
    - 访问元素时间复杂度为O(n)，比较费时间
### 2.栈Stack
限定仅在表尾进行插入和删除操作的线性表叫做栈。不含任何数据元素的栈为空栈，允许插入（入栈、进栈、压栈）和删除（出栈、弹栈） 的一端称为栈顶，另一端称为栈底。这种操作方式称为后进先出（LIFO）。

基本操作：
- 置空clear
- 判断是否为空empty
- 入栈push
- 出栈pop
- 获取栈顶元素top

应用：
1. 进制转换：例如159<sub>10</sub>转化为8进制，将159反复除以8，将每次的余数存入栈，最终依次将各个数出栈即可。其中栈顶为高位数字，栈底为低位数字。
2. 括号匹配：依次遍历表达式字符串，遇到左括号`(`入栈，右括号`)`出栈。若空栈时出栈或遍历完成后栈不为空，则括号不匹配。
3. 中缀表达式求值：准备**数字栈**和**符号栈**。在操作符末尾加入一个`#`
   1. 初始化：符号栈压入`#`
   2. 依次读取表达式中的每个字符
      1. 如果是数字，压入数字栈（不考虑多位数字）
      2. 如果是操作符，将其和符号栈栈顶元素比较优先级：
         1. 栈顶优先级低，元素入栈
         2. 优先级相等，出栈
         3. 栈顶优先级高，取出栈顶操作符，数字栈取出两个数字，运算后的结果存入数字栈，再将现有操作符和栈顶比较（重复4）
   3. 符号栈为空时处理完毕

- 优先级比较：
  - 乘除高于加减。
  - 两个符号都为加减，或者都为乘除，算栈顶元素优先级更低。
  - 除去`#`外，对于栈外元素，`(`优先级最低，`)`最高，栈顶元素相反。除非栈顶为`(`，读取元素为`)`，优先级相同。
  - `#`优先级低于任何元素，且优先级等于自身

4. 中缀表达式转后缀：只须一个符号栈
   1. 符号栈压入`#`
   2. 依次读取字符
      1. 数字直接输出
      2. 符号与栈顶元素比较
         1. 栈顶优先级低，入栈
         2. 相等，出栈不输出
         3. 栈顶优先级高，出栈并输出，重复4
    3. 栈为空时处理完毕

- 优先级比较：两个符号都为加减，或者都为乘除，算栈顶元素优先级更高。

5. 后缀表达式求值（后缀表达式无括号）：只须一个数字栈。依次读取字符，数字入栈，符号则取两个数字运算在存入栈中，直至整个表达式处理完成。 

#### 递归
可用子问题求解，且某一有限步的子问题有直接解的问题可用递归求解。递归基：定义最简单情况的求解，基地柜出口。递归步：将问题化为更简单的子问题的步骤。

应用：
1. 求阶乘：n!=n*(n-1)!,0!=1
2. 斐波那契数列：f(n)=f(n-1)+f(n-2),f(0)=f(1)=1
3. Ackerman函数
4. 多项式求解：p<sub>k</sub>=xp<sub>k-1</sub>+a<sub>n-k</sub>,n=0停止。
5. 全排列问题：先得到一个排列，生成第一个数确定后从第二个数开始的子排列。再将第一个数依次和其他数交换，并重复。只有一个元素时截止。
6. 整数划分：q(n,m)中n表示原数字，m为划分时出现的最大数。q(n,1)=q(1,m)=1。m>=n时q(n,m)=q(n,n)，否则q(n,m)=q(n,m-1)+q(n-m,m)。q(n,n)=1+q(n,n-1)。q(1,1)=1
7. 汉诺塔问题：n个圆盘。n=1时将圆盘从A移动到C，否则将1个从A移动到B，将n-1个移动到C，再将那一个移到C。

### 3.队列Queue
和栈相对，只能在队尾插入，在队首删除，先进先出（FIFO）
使用数组实现队列会出现队列溢出现象，含真溢出（数组全满）和假溢出（数组首部有空余位置）。使用循环队列解决假溢出。循环队列会出现rear==front时可能是队空或队满的歧义。解决方法：
- 增设count，用count==0或者MaxSize判断
- 增设flag判断
- 浪费一个元素空间(rear不存元素)，从0开始存储时，队空为front==rear，队满为((front+1)%MaxSize==rear)，入队：rear=(rear+1)%MaxSize,出队：front=(front+1)%MaxSize

### 4.串String
串是由若干个字符组成的有限序列，0个字符的串为空串。和其他的线性结构相比，特殊的基本操作有：
- 拼接两个串concat
- 求子串substr
- 定位子串index

模式匹配算法：子串定位运算
- 朴素模式匹配算法(Brute-Force算法) ：依次枚举。时间复杂性最好为O(n+m)，最坏为O(n*m)
- KMP算法：设主串为S，模式串为P，创建Next数组表示右移模式串的长度。next的建立实质为找模式串中的最长相同的前缀和后缀。若从1开始存数，有：next[1]=0,next[2]=1,对其他next[i],为之前[0,i-1]子串的首位重合个数+1。若第i个不匹配，模式串的比较位置变为next[i]。
```c++
int GetNext(string str,vector<int>&next){
    int len=str.length();
    next[1] = 0;
    int i = 1,j = 0;
    while(i<=len){
        if(j==0||str[i]==str[j]) next[++i] = ++j;
        else j = next[j];
    }
}
```
next数组的改进算法nextval:
```c++
if (p[i] != p[next[i]]) nextval[i] = next[i];
else nextval[i] = nextval[next[i]];
```
### 5.数组Array和广义表
#### 数组
数组的特点：元素数目固定、下标有界。二维数组的线性存储方式有行有限存储和列有限存储。

用数组可以实现对特殊矩阵的压缩存储：
- 三角矩阵：按先行后列的顺序线性存储。
- 对称矩阵：nxn的矩阵只需要存储n(n＋1)/2个元素，即只保留其上三角或下三角，按先行后列的顺序存储。比如保留下三角，对于第i行第j个元素的访问，若j>i可变为对第j行第i个元素的访问，否则访问第i*(i-1)/2+j-1个元素。
- 稀疏矩阵：大多元素为0的矩阵，考虑三元数组存储，即存储非零位置的行、列、数值。交换行列可以快速完成转置。

有n组数据的三元数组的快速转置算法：（维持数组的行优先存储顺序）
1. 遍历一遍三元数组，把每一列元素的个数求出来，存入数组num[n]
2. 创建数组cpot[n]，cpot[i]表示下一个第i列的数存储到新数组中的位置。cpot的第一个数为1（假设数组从1开始存），往后每一个cpot[i]=cpot[i-1]+num[i-1]。即第i列（新的第i行）的第一个数存在cpot[i]的位置。
3. 遍历原数组。对于原本在第i列的元素，存入新数组的第cpot[i]个。cpot[i]增1。注意交换原
   行和列。
4. 原行优先三元组遍历完成后，得到了转置后的、行优先存储的三元组。
#### 广义表
广义表的基本特征：
- 层次性：广义表的元素可以是子表，子表的元素依旧可以是子表（套娃）
- 共享性：一个广义表可以被多个表共享
- 递归性：广义表可以是自己的子表：E=(a,E)
基本概念：
- 表头：第一个元素（可以是表）
- 表尾：去掉第一个元素，剩下元素组成的表（必须是表）
- 深度：括号的重数。元素不含子表的表深度为1，递归表深度无穷大。
广义表的存储（链式结构）：
- 原子节点：表示原子项（单个元素，不含表）。节点包括标志域（tag，用于和表节点区分）
- 表节点：包括标志域、表头指针、表尾指针。表尾指针必然指向表节点。
---------------------------------
## Chapter3 Tree树
树是节点的集合。一棵树为空，或由一个根节点以及0个或多个子树构成。子树的根与根节点被有向边相连。子树不互相链接。树的本质是一对多的关系，反应了数据间的层次关系。树有以下基本概念：
- 度：某一节点非空子树的个数
- 分支节点：度不为0的节点
- 叶子节点：度为0的节点
- 层数与深度：从根节点开始将数据分层，越往下层数越大。深度为最大层数。
- 有序/无序树：子树次序不能/可以交换的树
- 森林：互不相交的树的集合
  
树的存储设计：
1. 双亲表示法：数组存储节点，每一个位置包含：该节点值和双亲的下标。根节点的双亲下标为-1。
2. 孩子表示法：数组存储节点，每一个位置包含：该节点值和一个指针。指针指向一个结构体，包含第一个儿子的下标和一个指针，指向第二个结构体，包含第二个儿子的下标和一个指针，依次类推。（即每个节点用连续存储，每个节点的儿子用链式存储表示）
3. 孩子兄弟表示法：链式存储。每个节点包括：节点值、指向第一个儿子的节点的指针、指向下一个兄弟的指针。

### 二叉树
子树最大为2、有次序之分（只有一个子树也有左右之分）。特殊的二叉树有：
- 满二叉树：所有分支节点都有两个子树，叶子节点在同一层。高度为k时节点个数为2<sup>k</sup>-1。
- 完全二叉树：所有叶子出现在最后一层和倒数第二层。除去最后一层，为满二叉树。最后一层的叶子节点集中在左边，若出现了只有一个儿子的节点，必为左儿子。总结即**按层次遍历时读到最后一个元素之前不能有空位置**。

二叉树特性:
- 第i层最多有2<sup>i-1</sup>个节点（从1开始计数）
- 高度为k度树最多有2<sup>k</sup>-1个节点
- 对任意二叉树，叶子节点个数=度为2的分支节点个数+1。
- n节点的完全二叉树的高度为 cell(log<sub>2</sub>n)+1 （cell为向上取整）
- 按层次顺序给完全二叉树节点从1开始编号，i的双亲为floor(i/2)，（i==1除外），左孩子为2\*i，右孩子为2\*i+1。i%2==0则有右兄弟，否则有左兄弟。i的层为floor(log<sub>2</sub>i)+1

二叉树的存储结构：
- 连续存储：同一般树的存储
- 链式存储：每个节点包含：数值、左儿子指针、右儿子指针。根据需要可加入双亲指针。

二叉树的遍历：
- 先序：先根，再左子树，最后右子树
- 中序：先左子树，后根，再右子树
- 后序：先左子树，再右子树，最后根
- 层次：层数优先，从左至右（队列实现）

### 线索（thread）二叉树
给二叉树中某种遍历下结点前驱（后继）的信息，即线索，形成线索二叉树。对于其左右节点，还需两个额外的标志域ltag和rtag，tag为0分别表示该节点的left和right指向的是左、右孩子，为1表示指向该节点按某种遍历方式的前驱或后继。综上，一个节点包含的信息有：左右节点lchild、rchild，左右标志ltag、rtag，以及该节点的数据data。

中序遍历的线索化：
```c++

void Thread(TreeNode node,TreeNode pre) {
    if(node==NULL) return;
 
    Thread(node->lchild,pre);       //将左子树线索化,

    if(node->lchild==NULL){         //若该节点没有左孩子 
        node->ltag = 1;             //修改标志域为前驱线索
        ndoe->lchild = pre;         //左孩子指向前驱结点
    }
    if(pre->rchild==NULL){          //若前驱没有右孩子
        pre->rtag = 1;              //修改标志域为后继线索
        pre->rchild = node;         //前驱右孩子指向当前结点
    }
    pre = node;                     //保持pre指向p的前驱
  
    Thread(node->rchild,pre);       //将右子树线索化
}
```
对某节点的前驱或后继元素的查找：
```c++
TreeNode* FindPre(TreeNode node){
    if(node->ltag==1) return node->lchild;  
    //左标志域为1表示左孩子指针就是前驱元素
    TreeNode *p = node->lchild;
    while(p->rtag==0) p=p->rchild;  //左儿子的最右的子孙为前驱
    return p;
}
TreeNode* FindNext(TreeNode node){
    if(node->rtag==1) return node->rchild;  
    TreeNode *p = node->rchild;
    while(p->ltag==0) p=p->lchild;
    return p;
}
```
对中序线索二叉树的中序遍历：
```c++
void inorder(TreeNode*root){
    TreeNode *p = root;
    while(p->ltag==0) p = p->left;
    //找到根节点最左边的子孙，即第一个节点。（左节点为空时ltag为1）
    cout<<p->data;
    while(p->rchild){   //rchild为NULL表示已经遍历到最后一个元素
        if(p->rtag){    //rtag==1，rchild就是下一个元素。
            p = p->rchild;
            if(p)cout<<p->data;
        }
        else{           //否则用上述方法找到下一个元素
            p=FindNext(p);
            cout<<p;
        }
    }
}
```
关于后序线索二叉树：后续线索二叉树需要在每个节点加入parent指针指向其父母节点。线索化时，先将左右儿子线索化，再对该节点线索化即可。与中序线索化仅是顺序的不同。而后序遍历有较大不同:
```c++
void postorder(TreeNode*root){
    TreeNode *cur,*pre;
    cur = root;
    while(cur->ltag==0)cur = cur->lchild;//找到第一个元素
    cout<<cur->data;
    while(cur){
        while(cur->rtag){       //rtag==1，rchild就是下一个元素。
            pre = cur;
            cur = cur->rchild;
            if(cur)cout<<cur->data;
        }
        if(cur == root){        //遍历到根节点，则访问到了最后一个元素
            cout<<root->data;
            break;
        }
        while(cur && cur->rchild = pre){//若左右儿子都已经遍历则回溯
            cout<<cur->data;
            pre = cur;
            cur = cur->parent;
        }
        if(cur && cur->rtag==0)cur = cur->rchild;//访问右儿子
    }
}
```
### 森林与二叉树的转换
1. 森林转化为二叉树：第一棵树的跟作为总的根节点，对每一节点，其左儿子为原来的第一个儿子，右儿子为其下一个兄弟（类似于树的儿子兄弟表示法。）
2. 二叉树转化为森林：上述的逆过程
3. 树转化为二叉树：同类似儿子兄弟表示法，左儿子为原来的第一个儿子，右儿子为原来的下一个兄弟
4. 二叉树转化为一般树：上述逆过程

需要注意的是，先序、后序遍历一棵树和一棵树对应的二叉树，结果是一样的。
### 哈夫曼树
路径长度：每个叶子节点到根节点的距离l与该叶子所带权重w的乘积wl之和$\sum(i=1,n)w_i*l_i$。构造哈弗曼树，使得路径长度最小。使用哈夫曼算法。
1. 将所有节点的权值排序
2. 选择两个最小的节点，作为一个父母节点的两个儿子。该父母节点的权值为两个儿子之和。将该节点放入节点集合，将其儿子的节点拿出。
3. 重复上述两步，直到只剩下一个节点，即根节点。

特点：
- 树中没有只有一个儿子的节点
- m片叶子的哈弗曼树有2m-1个节点
- 权值较大的叶子节点理根近，小的离根远
  
应用：霍夫曼编码实现数据压缩：按照字符出现频率作为权值，形成所有字符都是叶子节点的霍夫曼树，将左子树记为0，右子树记为1，可以获得最优前缀编码。前缀编码即编码集中，每个编码都不是其他编码的前缀，最优前缀编码即最短最简单的前缀编码（一套字符可对应多种最优前缀编码）。

### 二叉查找树
二叉查找树所有节点值互不相同。二叉查找树为空，或对任意一个节点，该个节点的左子树所有节点的值都小于该节点，右子树都大于该节点。左右子树也是二叉查找树。二叉查找树的中序遍历即所有节点值的顺序排序结果。相关操作有：
- 查找：用指针p从根节点开始查找。p的元素值等于查找值则查找成功。p节点元素值比查找值大则p进入左子树，否则进入右子树。p为空指针时查找失败。
- 插入：新节点总是作为叶子插入树中。
- 删除：对于任意一个节点的删除，有以下几种可能：
  - 该节点没有左右子树，则直接删除
  - 该节点只有左右子树的一个，则将子树的根节点作为被删除节点的替代
  - 该节点同时有左右子树，则用左子树最大元素或右子树最小元素作为该节点的替代，该元素所在节点不可能有左右子树，则将当做该节点删除，实行上述操作
### AVL二叉平衡树
AVL为空，或任意节点左右子树都为AVL，且高度差绝对值不超过1。故定义平衡因子balance为左右子树高度之差。

插入节点时新节点作为叶子节点，之后再维护AVL的平衡。包括：
- 左单旋：某节点的右子树高于左子树，且其右儿子的右子树高于左子树时，进行左单旋。该节点的右儿子变为原来右儿子的左儿子，原来的右儿子的左儿子变为该节点。以该节点为根的子树的跟变为该节点的右儿子。
- 右单旋：和左单旋相反。
- 左右双旋：某节点的左子树高于右子树且左儿子的右子树高于左子树时，进行左右双旋。先对该节点的左子树进行左单旋再对该节点进行右单旋。
- 右左双旋：和左右双旋相反。

对平衡的维护要求：插入某一个节点时，从插入的叶子节点开始依次往祖先回溯，直到根节点，若碰到平衡因子绝对值大于1的点则立即调整，再继续回溯。可以使用递归实现。
### B-树
一棵m阶B-树为空，或满足：
- 每个节点至多有m棵子树
- 根节点至少有两棵子树
- 除了根节点，其他节点至少有$\lceil$m/2$\rceil$棵子树
- 所有叶子节点处于同一层

每个节点包括：该节点的元素数n，关键字（元素）$k_1,k_2...k_n$，指向子树的指针$A_0,A_1...A_n$。注意：指针比关键字多1。关键字按升序排列，$A_0,A_1...A_n$指针指向的子树的数值分别：小于$k_1$、大于$k_1$且小于$k_2$、大于$k_2$且小于$k_3$...大于$k_n$。

相关操作：
- 查找：依次查找各个键值，与查找值相同则查找成功，若大于某一键值且小于下一键值时进入对应的子树。查找到空时查找失败。
- 插入：除了只存在根节点时，任何时候节点的元素（键值）个数应在[$\lceil m/2\rceil$-1，$\lceil m\rceil$-1]区间内。插入时直接插入叶子节点。若元素个数不到上限则直接插入，否则插入后对该节点进行分裂操作：（最坏情况，从插入的节点开始往根节点回溯，每个节点都要依次分裂）
  - 分裂后的左节点包括：n=$\lceil m/2\rceil$-1，$A_0...A_{\lceil m/2\rceil -1}$ , $k_1...k_{\lceil m/2\rceil -1}$
  - 分裂后的右节点包括：n=m-$\lceil m/2\rceil$，$A_{\lceil m/2\rceil -1}$...$A_m$ , $k_{\lceil m/2\rceil +1}...k_m$
  - 剩下的节点$k_{\lceil m/2\rceil}$和指向新右节点的元素送入原节点的双亲节点
- 删除：
  - 删除数据所在节点的数据个数不是最小值，则直接删除
  - 节点数据个数到达最小值，但其左或右兄弟的数据个数不是最小值，按照以下方法处理：（以右兄弟为例）
    - 将双亲节点的下一个键值放到该节点最后
    - 将右兄弟的最小元素替代双亲节点原来的键值
    - 右兄弟第一个指针变为该节点最后一个指针
  - 删除数据所在节点及其左或右兄弟的元素值都达到最小值或不存在左或右兄弟，则进行进行节点的合并：（右兄弟为例）
    - 若删除的是叶子节点，将父母节点的下一个键值和下一个指针所指的叶子的所有值合并作为一个节点加入原节点。
    - 若删除的不是叶子节点，则将删除键值的下一个指针的子树中最小的元素替换被删去的元素。该最小元素的删除如上所述。

### B+树
基本和B-树相同。不同的地方有：
- B+树的所有元素都在叶节点中。
- 对于某一个指针，指向节点的元素可以等于前一个键值。
- 叶子节点的指针指向索引的对象。
- 叶子节点的最大元素个数$m_1$自定。可以多于或少于m。但任意叶子节点的字数个数在[$\lceil m_1/2\rceil$,$m_1$]内。
- 叶子节点都有一个指针指向其右兄弟
- B+树有两个头指针，分别指向根节点和第一个叶子节点
- 插入时若某一节点要分裂，分裂的两个节点的关键码为$\lceil (m1+1)/2\rceil$和$\lfloor(m1+1)/2\rfloor$

--------------------------------------
## Chapter4 Graph 图
### 基本概念
图是顶点和边的集合。边定义为两个顶点形成的数对。

类型相关概念：
- 有向/无向图directed/undirected map：有向图的边\<x,y>称为弧，有方向性，分为弧头y和弧尾x。即边的数对有顺序区别,\<x,y\>!=\<y,x>。
- 完全图complete graph：每两个顶点之间都有边（不算顶点到自身的边）。对于n个顶点的无向图，共有n(n-1)/2条边。对于有向图，任意两点之间的双向路径都要存在，故有n(n-1)条弧。

图的性质相关概念：
- 顶点的度degree：对于无向图，顶点的度即为与顶点相连的边数，对于有向图，度分为出度和入度，前者为以该顶点为弧尾的边数，后者为以该顶点为弧头的弧数。
- 路径path：包含一组顶点$w_1,w_2...,w_n$与边<$w_1,w_2$>,<$w_2,w_3$>...<$w_{n-1},w_n$>。顶点有重复时称为非简单路径，$w_1==w_n$时称为回路。
- 权weigh：带权图的每条边含有权值。无权图可将每条边的全看做1。
- 邻接点adjace：\<v,w>存在时,w为v的邻接点
- 子图subgraph：顶点集和边集都为某图的顶点集和边集的子集的图为它的子图（边不能独立于顶点存在）

连通相关概念：
- 连通性：无向图的两点间有边则这两点是连通的。有向图的两点有相互的路径则这两点为强连通的
- 连通图：无向图任意两点都是连通的则整个图为连通图。强连通图定义类似。
- 连通分量：非连通图的极大连通子图为其连通分量。强连通分量定义类似。
- 生成树：对n个顶点e条边的图，其中n个顶点和n-1条边构成的极小连通子图为其生成树。

图与之前数据结构的比较：
- 对应关系：线性结构为1对1（线性关系），树为1对n（层次关系），图为n对n
- 相邻元素的关系：线性结构为前驱后继，树为双亲和孩子，顶点为邻接关系

### 图的存储
#### 邻接矩阵
建立顶点表，记录各个顶点的信息；建立邻接矩阵，表示各个顶点之间的关系。对于无权图，矩阵中元素1表示连通，否则为0；对于有权图，矩阵元素为顶点间路径的权值。无向图一定对称，有向图不一定。
#### 邻接表
顶点存在一个数组中。每一个顶点的节点包括：该顶点的信息data和指针firstarc，指向从该顶点出发的第一条边。边节点包括：数据adjvex，指向该边通向的顶点的数组的索引，nextarc指针，指向同一顶点出发的下一条边，该边的信息info。有向图的邻接表可分为邻接表（出边表）和逆邻接表（入边表）。
#### 十字链表
所有顶点存在头结点数组中
- 有向图：
  - 头结点包括：顶点数据data，指针firstin和firstout，分别指向以该节点为弧头、弧尾的第一个弧节点。
  - 弧节点包括：数据tailvex指示弧尾顶点，headvex指示弧头顶点，hlink指针，指向弧头相同的下一条弧，tlink，指向弧尾相同的下一条边，弧的信息info。
- 无向图：
  - 头结点包括：顶点数据data，第一条边firstedge。
  - 边节点包括：mark标志域，标记该边是否搜索过，ivex和jvex，标识该边连接的两顶点。ilink和jlink，分别指向两定点的下一条边，信息info。
### 图的遍历
使用数组visited[n]表示节点是否被访问过。深度优先搜索DFS（回溯算法，栈实现）、广度优先搜索BFS（队列）
### 最小生成树
对于带权图，其生成树所有边的权值之和称为生成树的代价。代价最小的称为最小生成树。基本的准则有：权值尽量小、n-1条边连接n个顶点、无回路。有以下两个算法生成最小生成树：
#### Prim普里姆算法
1. 任意选择一个顶点，作为初始顶点加入生成树顶点集合U
2. 在U和U之外各选择一个顶点，使得该边的权值最小，将该U之外的顶点加入U，且把边加入最小生成树的边的集合
3. 重复2直至U包含所有顶点

最小生成树的结果不唯一，但是代价相同。实现时需要设置2个数组：数组lowcost，记录U内每一顶点到U外各个顶点的最小权值，数组adjvex，记录每一顶点到哪个U外顶点的权值最小（U内节点的值为-1）。比如lowcost[4]==25，adjvex[4]==5，表示U外顶点4与U内所有顶点的距离比较，与U内顶点5的距离最近，为25。4加入U后将adjvex[4]改为-1。
#### Kruskal克鲁斯卡尔算法
每次都选择权值最小的边，若其两端顶点都在U中则找次小的边，将边加入边集合，两端的点若不在U内则加入U，直至U包含全部节点。
### AOV网
顶点表示活动，有向边表示优先关系$<v_i,v_j>$表示$v_i$必须在$v_j$活动进行前就进行了。例如：学生课程的前置与后置课程。

拓扑排序：将各个顶点进行排序，保证对于每一条弧，弧尾节点都在弧头节点之前。只有不出现环的有向图才能进行拓扑排序。拓扑排序的方法如下：
1. 输出没有直接前驱的节点，并删去和该节点相连的所有边
2. 重复上述步骤直至全部顶点都被输出。
3. 若还有顶点没被输出但已经没有无直接前驱的顶点了，说明存在环结构。
### AOE网
