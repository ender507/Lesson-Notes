# 数据结构与算法 学习笔记

[TOC]

## Chapter1 Introduction
### 1. 为什么学习数据结构
- 用计算机求解问题的基本步骤：分析问题->设计算法->编写程序->运行程序与验证结果->返回之前3个步骤重复，直至问题解决。

- 计算机科学是一门研究用计算机进行信息表示和处理的科学。设计的两个问题为：信息的表示（存储设计）和信息的处理（算法设计）。二者直接关系到程序的效率。数据结构与算法是研究数值与非数值计算问题中计算机的操作对象以及它们之间的关系和操作的学科，要求我们有分析问题并将问题中的内容抽象为有逻辑结构数据，并设计好数据的物理结构与算法，分析算法的复杂性，最终能够将算法在计算机中实现。

### 2. 相关定义与术语
- 数据Data：被用作描述对象，是一切能输入到计算机中并能被计算机程序识别和出力的符号集合，包括数值数据和非数值数据。
- 数据类型Data Type：包括数值范围和相关操作。
- 数据元素Data Element：数据的基本单位，在程序通常作为一个整体进行考虑和处理
- 数据项Data Item：构成数据元素的最小单位。
- 数据对象Data Object：具有相同性质的数据元素的集合。
  
  例如：数据类型为链表，则数据元素为各个节点，每个节点的数据项有指针、数值等等。
- 逻辑结构：
  - 集合：各个元素确定、互异、无序，同属一个集合，别无其他联系。
  - 线性结构：元素有唯一直接前驱和后继，表现为线性关系
  - 树结构：元素之间存在一对多的层次关系
  - 图结构：元素之间存在多对多的任意关系。任意指结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。 
- 物理结构：数据及其逻辑结构如何储存在计算机中
  - 直接访问：可用于连续设计，数据元素之间的逻辑关系可 以由元素的存储位置来表示 
  - 间接访问：可用于连接设计，数据元素之间的逻辑关系将 由指针进行关联和表示 

- 数据结构Data Structures：包括逻辑结构、物理结构和操作集。

数据的逻辑结构属于用户视图，是面向问题的， 反映了数据内部的构成方式；数据的存储结构属 于具体实现的视图，是面向计算机的。  一种数据的逻辑结构可以用多种存储结构来存储， 而采用不同的存储结构，其数据处理的效率往往 是不同的。 
### 3. 抽象数据类型ADT
ADT的定义仅是一组逻辑特性描述， 与其在计算机内的表示和实现无关。因此，不论ADT的内部结构如何变化，只要其数学特性不变，都不影响其外部使用。

数据类型可以看作是已经实现了的抽象数据类型。如：int型数据：ADT int=( {x |x∈Z}，{+,-,*,/,%, ≦,==} ) 

ADT应包括数据对象、数据关系、基本操作。其中，基本操作应包括初始条件、操作结果。需要指出输入、输出、前置条件（输入满足的条件）和后置条件（输出满足的条件）。

### 4. 算法
算法是使用确定可行的详细步骤处理输入数据，得到输出数据的解决问题的执行方法，具有5个重要特征：
- 确定性：每一种运算必须有确切定义，不能有二义性
- 可行性：可以通过已经实现的基本操作执行有限次来实现
- 输入：算法有**0个或多个**输入，全部取自定义域
- 输出：算法有**1个或多个**输出
- 有限性：算法执行有限步之后能够终止。
 
算法的描述方法：
- 自然语言：容易理解却冗长，有二义性
- 流程图：流程直观，但缺少严密性、灵活性
- 伪代码：表达能力强，抽象性强，易理解
- 程序语言：能直接用计算机执行，但抽象性差

一个优秀的算法要有以下特质：
- 正确性，能够正确解决问题
- 可读性，易于理解
- 健壮性，便于维护和修改
- 效率高，使用较少的计算机资源解决问题，使用较少的时间和空间。故分析算法时需要考虑：
  - 时间复杂性：使用基本操作的语句的执行次数的渐进阶进行评估。
  - 空间复杂性：执行过程中的最大储存量需求。

### 5.设计思路
程序=数据结构+算法。解决问题时，要在分析问题后，确定数据的逻辑结构，设计其物理结构，再确定其操作。先建模后确定算法。接着逐步求精，直至能够实现ADT。

-----------------------------------------------
## Chapter2 Linear Structure线性结构
### 1.线性表List
L=(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>),其中a<sub>i</sub>为数据元素，i为位置或序号，n为表长。链表具有以下特征：
- 有限性：链表元素个数有穷
- 向同性：元素类型相同
- 相继性：除了第一个元素a<sub>1</sub>无直接前驱，最后一个元素a<sub>n</sub>无直接后继外，任意一个元素a<sub>i</sub>都有**唯一**直接前驱a<sub>i-1</sub>和直接后继a<sub>i+1</sub>

对表的基本操作有：
1. 求表长len
2. 对某位置的元素进行读写get
3. 按值对元素位置进行查找search
4. 按位置插入insert
5. 按位置或值删除delete

物理结构设计：
- 顺序存储：使用连续地址空间进行存储元素，物理位置的相邻表示逻辑上的相邻。若每个元素站地址空间为c，则地址位置loc(a<sub>i</sub>)=loc(a<sub>i</sub>)+(i-1)*c
  - 优点
    - 结构简单
    - 连续地址空间结构紧凑，存储效率高，不需要为表示逻辑关系而增加额外空间
    - 顺序表是随机存储结构，按位置访问元素的时间是常数时间
  - 缺点
    - 插入删除时需要移动较多元素以保持物理空间的连续性，效率较低
    - 对于长度变化较大的线性表，需要预先分配较大空间或扩充，造成不便
- 链式存储：利用散列在计算机中的存储单元，地址不一定连续。各个单元通过保存储存的地址（指针）来关联。
  - 优点
    - 容量灵活，易扩充
    - 已知位置时，插入和删除元素的时间开销为常数
  - 缺点
    - 需要额外的空间表示逻辑关系
    - 访问元素时间复杂度为O(n)，比较费时间
### 2.栈Stack
限定仅在表尾进行插入和删除操作的线性表叫做栈。不含任何数据元素的栈为空栈，允许插入（入栈、进栈、压栈）和删除（出栈、弹栈） 的一端称为栈顶，另一端称为栈底。这种操作方式称为后进先出（LIFO）。

基本操作：
- 置空clear
- 判断是否为空empty
- 入栈push
- 出栈pop
- 获取栈顶元素top

应用：
1. 进制转换：例如159<sub>10</sub>转化为8进制，将159反复除以8，将每次的余数存入栈，最终依次将各个数出栈即可。其中栈顶为高位数字，栈底为低位数字。
2. 括号匹配：依次遍历表达式字符串，遇到左括号`(`入栈，右括号`)`出栈。若空栈时出栈或遍历完成后栈不为空，则括号不匹配。
3. 中缀表达式求值：准备**数字栈**和**符号栈**。在操作符末尾加入一个`#`
   1. 初始化：符号栈压入`#`
   2. 依次读取表达式中的每个字符
      1. 如果是数字，压入数字栈（不考虑多位数字）
      2. 如果是操作符，将其和符号栈栈顶元素比较优先级：
         1. 栈顶优先级低，元素入栈
         2. 优先级相等，出栈
         3. 栈顶优先级高，取出栈顶操作符，数字栈取出两个数字，运算后的结果存入数字栈，再将现有操作符和栈顶比较（重复4）
   3. 符号栈为空时处理完毕

- 优先级比较：
  - 乘除高于加减。
  - 两个符号都为加减，或者都为乘除，算栈顶元素优先级更低。
  - 除去`#`外，对于栈外元素，`(`优先级最低，`)`最高，栈顶元素相反。除非栈顶为`(`，读取元素为`)`，优先级相同。
  - `#`优先级低于任何元素，且优先级等于自身

4. 中缀表达式转后缀：只须一个符号栈
   1. 符号栈压入`#`
   2. 依次读取字符
      1. 数字直接输出
      2. 符号与栈顶元素比较
         1. 栈顶优先级低，入栈
         2. 相等，出栈不输出
         3. 栈顶优先级高，出栈并输出，重复4
    3. 栈为空时处理完毕

- 优先级比较：两个符号都为加减，或者都为乘除，算栈顶元素优先级更高。

5. 后缀表达式求值（后缀表达式无括号）：只须一个数字栈。依次读取字符，数字入栈，符号则取两个数字运算在存入栈中，直至整个表达式处理完成。 

#### 递归
可用子问题求解，且某一有限步的子问题有直接解的问题可用递归求解。递归基：定义最简单情况的求解，基地柜出口。递归步：将问题化为更简单的子问题的步骤。

应用：
1. 求阶乘：n!=n*(n-1)!,0!=1
2. 斐波那契数列：f(n)=f(n-1)+f(n-2),f(0)=f(1)=1
3. Ackerman函数
4. 多项式求解：p<sub>k</sub>=xp<sub>k-1</sub>+a<sub>n-k</sub>,n=0停止。
5. 全排列问题：先得到一个排列，生成第一个数确定后从第二个数开始的子排列。再将第一个数依次和其他数交换，并重复。只有一个元素时截止。
6. 整数划分：q(n,m)中n表示原数字，m为划分时出现的最大数。q(n,1)=q(1,m)=1。m>=n时q(n,m)=q(n,n)，否则q(n,m)=q(n,m-1)+q(n-m,m)。q(n,n)=1+q(n,n-1)。q(1,1)=1
7. 汉诺塔问题：n个圆盘。n=1时将圆盘从A移动到C，否则将1个从A移动到B，将n-1个移动到C，再将那一个移到C。

### 3.队列Queue
和栈相对，只能在队尾插入，在队首删除，先进先出（FIFO）
使用数组实现队列会出现队列溢出现象，含真溢出（数组全满）和假溢出（数组首部有空余位置）。使用循环队列解决假溢出。循环队列会出现rear==front时可能是队空或队满的歧义。解决方法：
- 增设count，用count==0或者MaxSize判断
- 增设flag判断
- 浪费一个元素空间(rear不存元素)，从0开始存储时，队空为front==rear，队满为((front+1)%MaxSize==rear)，入队：rear=(rear+1)%MaxSize,出队：front=(front+1)%MaxSize

### 4.串String
串是由若干个字符组成的有限序列，0个字符的串为空串。和其他的线性结构相比，特殊的基本操作有：
- 拼接两个串concat
- 求子串substr
- 定位子串index

模式匹配算法：子串定位运算
- 朴素模式匹配算法(Brute-Force算法) ：依次枚举。时间复杂性最好为O(n+m)，最坏为O(n*m)
- KMP算法：设主串为S，模式串为P，创建Next数组表示右移模式串的长度。next的建立实质为找模式串中的最长相同的前缀和后缀。若从1开始存数，有：next[1]=0,next[2]=1,对其他next[i],为之前[0,i-1]子串的首位重合个数+1。若第i个不匹配，模式串的比较位置变为next[i]。
```c++
int GetNext(string str,vector<int>&next){
    int len=str.length();
    next[1] = 0;
    int i = 1,j = 0;
    while(i<=len){
        if(j==0||str[i]==str[j]) next[++i] = ++j;
        else j = next[j];
    }
}
```
next数组的改进算法nextval:
```c++
if (p[i] != p[next[i]]) nextval[i] = next[i];
else nextval[i] = nextval[next[i]];
```
### 5.数组Array和广义表
#### 数组
数组的特点：元素数目固定、下标有界。二维数组的线性存储方式有行有限存储和列有限存储。

用数组可以实现对特殊矩阵的压缩存储：
- 三角矩阵：按先行后列的顺序线性存储。
- 对称矩阵：nxn的矩阵只需要存储n(n＋1)/2个元素，即只保留其上三角或下三角，按先行后列的顺序存储。比如保留下三角，对于第i行第j个元素的访问，若j>i可变为对第j行第i个元素的访问，否则访问第i*(i-1)/2+j-1个元素。
- 稀疏矩阵：大多元素为0的矩阵，考虑三元数组存储，即存储非零位置的行、列、数值。交换行列可以快速完成转置。

有n组数据的三元数组的快速转置算法：（维持数组的行优先存储顺序）
1. 遍历一遍三元数组，把每一列元素的个数求出来，存入数组num[n]
2. 创建数组cpot[n]，cpot[i]表示下一个第i列的数存储到新数组中的位置。cpot的第一个数为1（假设数组从1开始存），往后每一个cpot[i]=cpot[i-1]+num[i-1]。即第i列（新的第i行）的第一个数存在cpot[i]的位置。
3. 遍历原数组。对于原本在第i列的元素，存入新数组的第cpot[i]个。cpot[i]增1。注意交换原
   行和列。
4. 原行优先三元组遍历完成后，得到了转置后的、行优先存储的三元组。
#### 广义表
广义表的基本特征：
- 层次性：广义表的元素可以是子表，子表的元素依旧可以是子表（套娃）
- 共享性：一个广义表可以被多个表共享
- 递归性：广义表可以是自己的子表：E=(a,E)
基本概念：
- 表头：第一个元素（可以是表）
- 表尾：去掉第一个元素，剩下元素组成的表（必须是表）
- 深度：括号的重数。元素不含子表的表深度为1，递归表深度无穷大。
广义表的存储（链式结构）：
- 原子节点：表示原子项（单个元素，不含表）。节点包括标志域（tag，用于和表节点区分）
- 表节点：包括标志域、表头指针、表尾指针。表尾指针必然指向表节点。
---------------------------------
## Chapter3 Tree树
树是节点的集合。一棵树为空，或由一个根节点以及0个或多个子树构成。子树的根与根节点被有向边相连。子树不互相链接。树的本质是一对多的关系，反应了数据间的层次关系。树有以下基本概念：
- 度：某一节点非空子树的个数
- 分支节点：度不为0的节点
- 叶子节点：度为0的节点
- 层数与深度：从根节点开始将数据分层，越往下层数越大。深度为最大层数。
- 有序/无序树：子树次序不能/可以交换的树
- 森林：互不相交的树的集合
  
树的存储设计：
1. 双亲表示法：数组存储节点，每一个位置包含：该节点值和双亲的下标。根节点的双亲下标为-1。
2. 孩子表示法：数组存储节点，每一个位置包含：该节点值和一个指针。指针指向一个结构体，包含第一个儿子的下标和一个指针，指向第二个结构体，包含第二个儿子的下标和一个指针，依次类推。（即每个节点用连续存储，每个节点的儿子用链式存储表示）
3. 孩子兄弟表示法：链式存储。每个节点包括：节点值、指向第一个儿子的节点的指针、指向下一个兄弟的指针。

### 二叉树
子树最大为2、有次序之分（只有一个子树也有左右之分）。特殊的二叉树有：
- 满二叉树：所有分支节点都有两个子树，叶子节点在同一层。高度为k时节点个数为2<sup>k</sup>-1。
- 完全二叉树：所有叶子出现在最后一层和倒数第二层。除去最后一层，为满二叉树。最后一层的叶子节点集中在左边，若出现了只有一个儿子的节点，必为左儿子。总结即**按层次遍历时读到最后一个元素之前不能有空位置**。

二叉树特性:
- 第i层最多有2<sup>i-1</sup>个节点（从1开始计数）
- 高度为k度树最多有2<sup>k</sup>-1个节点
- 对任意二叉树，叶子节点个数=度为2的分支节点个数+1。
- n节点的完全二叉树的高度为 cell(log<sub>2</sub>n)+1 （cell为向上取整）
- 按层次顺序给完全二叉树节点从1开始编号，i的双亲为floor(i/2)，（i==1除外），左孩子为2\*i，右孩子为2\*i+1。i%2==0则有右兄弟，否则有左兄弟。i的层为floor(log<sub>2</sub>i)+1

二叉树的存储结构：
- 连续存储：同一般树的存储
- 链式存储：每个节点包含：数值、左儿子指针、右儿子指针。根据需要可加入双亲指针。

二叉树的遍历：
- 先序：先根，再左子树，最后右子树
- 中序：先左子树，后根，再右子树
- 后序：先左子树，再右子树，最后根
- 层次：层数优先，从左至右（队列实现）

### 线索（thread）二叉树
给二叉树中某种遍历下结点前驱（后继）的信息，即线索，形成线索二叉树。对于其左右节点，还需两个额外的标志域ltag和rtag，tag为0分别表示该节点的left和right指向的是左、右孩子，为1表示指向该节点按某种遍历方式的前驱或后继。综上，一个节点包含的信息有：左右节点lchild、rchild，左右标志ltag、rtag，以及该节点的数据data。

中序遍历的线索化：
```c++

void Thread(TreeNode node,TreeNode pre) {
    if(node==NULL) return;
 
    Thread(node->lchild,pre);       //将左子树线索化,

    if(node->lchild==NULL){         //若该节点没有左孩子 
        node->ltag = 1;             //修改标志域为前驱线索
        ndoe->lchild = pre;         //左孩子指向前驱结点
    }
    if(pre->rchild==NULL){          //若前驱没有右孩子
        pre->rtag = 1;              //修改标志域为后继线索
        pre->rchild = node;         //前驱右孩子指向当前结点
    }
    pre = node;                     //保持pre指向p的前驱
  
    Thread(node->rchild,pre);       //将右子树线索化
}
```
对某节点的前驱或后继元素的查找：
```c++
TreeNode* FindPre(TreeNode node){
    if(node->ltag==1) return node->lchild;  
    //左标志域为1表示左孩子指针就是前驱元素
    TreeNode *p = node->lchild;
    while(p->rtag==0) p=p->rchild;  //左儿子的最右的子孙为前驱
    return p;
}
TreeNode* FindNext(TreeNode node){
    if(node->rtag==1) return node->rchild;  
    TreeNode *p = node->rchild;
    while(p->ltag==0) p=p->lchild;
    return p;
}
```
对中序线索二叉树的中序遍历：
```c++
void inorder(TreeNode*root){
    TreeNode *p = root;
    while(p->ltag==0) p = p->left;
    //找到根节点最左边的子孙，即第一个节点。（左节点为空时ltag为1）
    cout<<p->data;
    while(p->rchild){   //rchild为NULL表示已经遍历到最后一个元素
        if(p->rtag){    //rtag==1，rchild就是下一个元素。
            p = p->rchild;
            if(p)cout<<p->data;
        }
        else{           //否则用上述方法找到下一个元素
            p=FindNext(p);
            cout<<p;
        }
    }
}
```
关于后序线索二叉树：后续线索二叉树需要在每个节点加入parent指针指向其父母节点。线索化时，先将左右儿子线索化，再对该节点线索化即可。与中序线索化仅是顺序的不同。而后序遍历有较大不同:
```c++
void postorder(TreeNode*root){
    TreeNode *cur,*pre;
    cur = root;
    while(cur->ltag==0)cur = cur->lchild;//找到第一个元素
    cout<<cur->data;
    while(cur){
        while(cur->rtag){       //rtag==1，rchild就是下一个元素。
            pre = cur;
            cur = cur->rchild;
            if(cur)cout<<cur->data;
        }
        if(cur == root){        //遍历到根节点，则访问到了最后一个元素
            cout<<root->data;
            break;
        }
        while(cur && cur->rchild = pre){//若左右儿子都已经遍历则回溯
            cout<<cur->data;
            pre = cur;
            cur = cur->parent;
        }
        if(cur && cur->rtag==0)cur = cur->rchild;//访问右儿子
    }
}
```
### 森林与二叉树的转换
1. 森林转化为二叉树：第一棵树的跟作为总的根节点，对每一节点，其左儿子为原来的第一个儿子，右儿子为其下一个兄弟（类似于树的儿子兄弟表示法。）
2. 二叉树转化为森林：上述的逆过程
3. 树转化为二叉树：同类似儿子兄弟表示法，左儿子为原来的第一个儿子，右儿子为原来的下一个兄弟
4. 二叉树转化为一般树：上述逆过程

需要注意的是，先序、后序遍历一棵树和一棵树对应的二叉树，结果是一样的。
### 哈夫曼树
路径长度：每个叶子节点到根节点的距离l与该叶子所带权重w的乘积wl之和$\sum(i=1,n)w_i*l_i$。构造哈弗曼树，使得路径长度最小。使用哈夫曼算法。
1. 将所有节点的权值排序
2. 选择两个最小的节点，作为一个父母节点的两个儿子。该父母节点的权值为两个儿子之和。将该节点放入节点集合，将其儿子的节点拿出。
3. 重复上述两步，直到只剩下一个节点，即根节点。

特点：
- 树中没有只有一个儿子的节点
- m片叶子的哈弗曼树有2m-1个节点
- 权值较大的叶子节点理根近，小的离根远
  
应用：霍夫曼编码实现数据压缩：按照字符出现频率作为权值，形成所有字符都是叶子节点的霍夫曼树，将左子树记为0，右子树记为1，可以获得最优前缀编码。前缀编码即编码集中，每个编码都不是其他编码的前缀，最优前缀编码即最短最简单的前缀编码（一套字符可对应多种最优前缀编码）。

### 二叉查找树
二叉查找树所有节点值互不相同。二叉查找树为空，或对任意一个节点，该个节点的左子树所有节点的值都小于该节点，右子树都大于该节点。左右子树也是二叉查找树。二叉查找树的中序遍历即所有节点值的顺序排序结果。相关操作有：
- 查找：用指针p从根节点开始查找。p的元素值等于查找值则查找成功。p节点元素值比查找值大则p进入左子树，否则进入右子树。p为空指针时查找失败。
- 插入：新节点总是作为叶子插入树中。
- 删除：对于任意一个节点的删除，有以下几种可能：
  - 该节点没有左右子树，则直接删除
  - 该节点只有左右子树的一个，则将子树的根节点作为被删除节点的替代
  - 该节点同时有左右子树，则用左子树最大元素或右子树最小元素作为该节点的替代，该元素所在节点不可能有左右子树，则将当做该节点删除，实行上述操作
### AVL二叉平衡树
AVL为空，或任意节点左右子树都为AVL，且高度差绝对值不超过1。故定义平衡因子balance为左右子树高度之差。

插入节点时新节点作为叶子节点，之后再维护AVL的平衡。包括：
- 左单旋：某节点的右子树高于左子树，且其右儿子的右子树高于左子树时，进行左单旋。该节点的右儿子变为原来右儿子的左儿子，原来的右儿子的左儿子变为该节点。以该节点为根的子树的跟变为该节点的右儿子。
- 右单旋：和左单旋相反。
- 左右双旋：某节点的左子树高于右子树且左儿子的右子树高于左子树时，进行左右双旋。先对该节点的左子树进行左单旋再对该节点进行右单旋。
- 右左双旋：和左右双旋相反。

对平衡的维护要求：插入某一个节点时，从插入的叶子节点开始依次往祖先回溯，直到根节点，若碰到平衡因子绝对值大于1的点则立即调整，再继续回溯。可以使用递归实现。
### B-树
一棵m阶B-树为空，或满足：
- 每个节点至多有m棵子树
- 根节点至少有两棵子树
- 除了根节点，其他节点至少有$\lceil$m/2$\rceil$棵子树
- 所有叶子节点处于同一层

每个节点包括：该节点的元素数n，关键字（元素）$k_1,k_2...k_n$，指向子树的指针$A_0,A_1...A_n$。注意：指针比关键字多1。关键字按升序排列，$A_0,A_1...A_n$指针指向的子树的数值分别：小于$k_1$、大于$k_1$且小于$k_2$、大于$k_2$且小于$k_3$...大于$k_n$。

相关操作：
- 查找：依次查找各个键值，与查找值相同则查找成功，若大于某一键值且小于下一键值时进入对应的子树。查找到空时查找失败。
- 插入：除了只存在根节点时，任何时候节点的元素（键值）个数应在[$\lceil m/2\rceil$-1，$\lceil m\rceil$-1]区间内。插入时直接插入叶子节点。若元素个数不到上限则直接插入，否则插入后对该节点进行分裂操作：（最坏情况，从插入的节点开始往根节点回溯，每个节点都要依次分裂）
  - 分裂后的左节点包括：n=$\lceil m/2\rceil$-1，$A_0...A_{\lceil m/2\rceil -1}$ , $k_1...k_{\lceil m/2\rceil -1}$
  - 分裂后的右节点包括：n=m-$\lceil m/2\rceil$，$A_{\lceil m/2\rceil -1}$...$A_m$ , $k_{\lceil m/2\rceil +1}...k_m$
  - 剩下的节点$k_{\lceil m/2\rceil}$和指向新右节点的元素送入原节点的双亲节点
- 删除：
  - 删除数据所在节点的数据个数不是最小值，则直接删除
  - 节点数据个数到达最小值，但其左或右兄弟的数据个数不是最小值，按照以下方法处理：（以右兄弟为例）
    - 将双亲节点的下一个键值放到该节点最后
    - 将右兄弟的最小元素替代双亲节点原来的键值
    - 右兄弟第一个指针变为该节点最后一个指针
  - 删除数据所在节点及其左或右兄弟的元素值都达到最小值或不存在左或右兄弟，则进行进行节点的合并：（右兄弟为例）
    - 若删除的是叶子节点，将父母节点的下一个键值和下一个指针所指的叶子的所有值合并作为一个节点加入原节点。
    - 若删除的不是叶子节点，则将删除键值的下一个指针的子树中最小的元素替换被删去的元素。该最小元素的删除如上所述。

### B+树
基本和B-树相同。不同的地方有：
- B+树的所有元素都在叶节点中。
- 对于某一个指针，指向节点的元素可以等于前一个键值。
- 叶子节点的指针指向索引的对象。
- 叶子节点的最大元素个数$m_1$自定。可以多于或少于m。但任意叶子节点的字数个数在[$\lceil m_1/2\rceil$,$m_1$]内。
- 叶子节点都有一个指针指向其右兄弟
- B+树有两个头指针，分别指向根节点和第一个叶子节点
- 插入时若某一节点要分裂，分裂的两个节点的关键码为$\lceil (m1+1)/2\rceil$和$\lfloor(m1+1)/2\rfloor$

--------------------------------------
## Chapter4 Graph 图
### 基本概念
图是顶点和边的集合。边定义为两个顶点形成的数对。

类型相关概念：
- 有向/无向图directed/undirected map：有向图的边\<x,y>称为弧，有方向性，分为弧头y和弧尾x。即边的数对有顺序区别,\<x,y\>!=\<y,x>。
- 完全图complete graph：每两个顶点之间都有边（不算顶点到自身的边）。对于n个顶点的无向图，共有n(n-1)/2条边。对于有向图，任意两点之间的双向路径都要存在，故有n(n-1)条弧。

图的性质相关概念：
- 顶点的度degree：对于无向图，顶点的度即为与顶点相连的边数，对于有向图，度分为出度和入度，前者为以该顶点为弧尾的边数，后者为以该顶点为弧头的弧数。
- 路径path：包含一组顶点$w_1,w_2...,w_n$与边<$w_1,w_2$>,<$w_2,w_3$>...<$w_{n-1},w_n$>。顶点有重复时称为非简单路径，$w_1==w_n$时称为回路。
- 权weigh：带权图的每条边含有权值。无权图可将每条边的全看做1。
- 邻接点adjace：\<v,w>存在时,w为v的邻接点
- 子图subgraph：顶点集和边集都为某图的顶点集和边集的子集的图为它的子图（边不能独立于顶点存在）

连通相关概念：
- 连通性：无向图的两点间有边则这两点是连通的。有向图的两点有相互的路径则这两点为强连通的
- 连通图：无向图任意两点都是连通的则整个图为连通图。强连通图定义类似。
- 连通分量：非连通图的极大连通子图为其连通分量。强连通分量定义类似。
- 生成树：对n个顶点e条边的图，其中n个顶点和n-1条边构成的极小连通子图为其生成树。

图与之前数据结构的比较：
- 对应关系：线性结构为1对1（线性关系），树为1对n（层次关系），图为n对n
- 相邻元素的关系：线性结构为前驱后继，树为双亲和孩子，顶点为邻接关系

### 图的存储
#### 邻接矩阵
建立顶点表，记录各个顶点的信息；建立邻接矩阵，表示各个顶点之间的关系。对于无权图，矩阵中元素1表示连通，否则为0；对于有权图，矩阵元素为顶点间路径的权值。无向图一定对称，有向图不一定。
#### 邻接表
顶点存在一个数组中。每一个顶点的节点包括：该顶点的信息data和指针firstarc，指向从该顶点出发的第一条边。边节点包括：数据adjvex，指向该边通向的顶点的数组的索引，nextarc指针，指向同一顶点出发的下一条边，该边的信息info。有向图的邻接表可分为邻接表（出边表）和逆邻接表（入边表）。
#### 十字链表
所有顶点存在头结点数组中
- 有向图：
  - 头结点包括：顶点数据data，指针firstin和firstout，分别指向以该节点为弧头、弧尾的第一个弧节点。
  - 弧节点包括：数据tailvex指示弧尾顶点，headvex指示弧头顶点，hlink指针，指向弧头相同的下一条弧，tlink，指向弧尾相同的下一条边，弧的信息info。
- 无向图：
  - 头结点包括：顶点数据data，第一条边firstedge。
  - 边节点包括：mark标志域，标记该边是否搜索过，ivex和jvex，标识该边连接的两顶点。ilink和jlink，分别指向两定点的下一条边，信息info。
### 图的遍历
使用数组visited[n]表示节点是否被访问过。深度优先搜索DFS（回溯算法，栈实现）、广度优先搜索BFS（队列）
### 最小生成树
对于带权图，其生成树所有边的权值之和称为生成树的代价。代价最小的称为最小生成树。基本的准则有：权值尽量小、n-1条边连接n个顶点、无回路。有以下两个算法生成最小生成树：
#### Prim普里姆算法
1. 任意选择一个顶点，作为初始顶点加入生成树顶点集合U
2. 在U和U之外各选择一个顶点，使得该边的权值最小，将该U之外的顶点加入U，且把边加入最小生成树的边的集合
3. 重复2直至U包含所有顶点

最小生成树的结果不唯一，但是代价相同。实现时需要设置2个数组：数组lowcost，记录U内每一顶点到U外各个顶点的最小权值，数组adjvex，记录每一顶点到哪个U外顶点的权值最小（U内节点的值为-1）。比如lowcost[4]==25，adjvex[4]==5，表示U外顶点4与U内所有顶点的距离比较，与U内顶点5的距离最近，为25。4加入U后将adjvex[4]改为-1。
#### Kruskal克鲁斯卡尔算法
每次都选择权值最小的边，若其两端顶点都在U中则找次小的边，将边加入边集合，两端的点若不在U内则加入U，直至U包含全部节点。
### AOV网
顶点表示活动，有向边表示优先关系$<v_i,v_j>$表示$v_i$必须在$v_j$活动进行前就进行了。例如：学生课程的前置与后置课程。

拓扑排序：将各个顶点进行排序，保证对于每一条弧，弧尾节点都在弧头节点之前。只有不出现环的有向图才能进行拓扑排序。拓扑排序的方法如下：
1. 输出没有直接前驱的节点，并删去和该节点相连的所有边
2. 重复上述步骤直至全部顶点都被输出。
3. 若还有顶点没被输出但已经没有无直接前驱的顶点了，说明存在环结构。
### AOE网
边表示活动，其权值表示持续时间，顶点表示事件（检查点）。入度为0的点为源点，出度为0的点为汇点。完成整个工程的时间取决于从源点到汇点的最长路径的长度，该路径称为关键路径，路径上的活动为关键活动。计算关键活动需要：
1. 数组ve[i]，表示$v_0$到$v_i$的最长路径长。从前往后计算，ve[i]=max(ve[j]+dur(\<$v_j,v_i$>)),其中，<$v_j,v_i$>是所有指向$v_i$的边。
2. 数组vl[i]，表示$v_{n-1}$在ve[n-1]时刻完成的前提下$v_i$的最迟允许开始时间。从后往前反推，vl[i]=min(vl[j]-dur(<$v_i,v_j$>))。
3. 数组e[k],其中，事件$a_k$在边<$v_i,v_j$>上。e[k]是源点$v_0$到$v_i$的最长路径长度。故有v[k]=ve[i]。
4. 数组l[k]，表示活动$a_k$最迟的开始时间。l[k]=vl[i]-dur(\<i,j>)。
5. 时间余量l[k]-e[k],即最早可能开始时间和最迟允许开始时间之差，为0表示没有时间余量，则$a_k$为关键活动。

### 最短路径
#### Dijkstra算法 $O(n^2)$
1. 创建dist[i]表示$v_0$到$v_i$的最短路径长度。初始时，$v_0$到$v_i$有边，则dist[i]为边的权值，否则为无穷大。将顶点$v_0$存入顶点集合S。
2. 对所有使得$v_i$不在S中的i，查找dist[i]中的最小值。将找到后的顶点$v_i$存入S。
3. 若有路径<$v_i,v_j$>，其中$v_j$不在S中，则dist[j]=min(dist[j],dist[i]+len(\<i,j>))。
4. 重复2，3直至所有顶点都在S中。
#### Floyd算法 $O(n^3)$
1. 矩阵A<sub>0</sub>=C，即为初始的邻接矩阵
2. A<sub>k+1</sub>[ i ][ j ]=min( A<sub>k</sub>[ i ][ j ] , A<sub>k</sub>[ k ][ j ]+A<sub>k</sub>[ i ][ k ] )
3. 若有n个顶点（从1开始计数），则最终迭代到A<sub>n</sub>

在迭代中，若A<sub>k+1</sub>[ i ][ j ]=A<sub>k</sub>[ k ][ j ]+A<sub>k</sub>[ i ][ k ] 则说目前$v_i$到$v_j$的最短路径是$v_i$经过$v_k$再到达$v_j$。
### 网络流问题
网络或网络容量是一个带权有向图，有一个源点和一个汇点。权值表示流量上限，所有流能由源点流出，流至汇点。网络流问题求的是最大流量。
1. 构建流图和残余图。一开始流图为空，残余图为原图。
2. 从残余图中任选一条从源点到汇点的路径，达到流量最大值，加入流图，残余图的该路径的每条边的权值减去该流量最大值。
3. 重复2，直至残余图从源点到汇点再无路径

贪心算法。
### 双联通性算法
将一个连通无向图的节点a删去，该图不再连通，则a是原图的关节点。没有关节点的图称为双连通图。双连通图的任意两个顶点间至少有两条路径互通。关节点分为：
- 第一类关节点：以该点作为生成树的根，有两棵及以上的子树。删去该节点，各个子树会孤立起来，形成森林。
- 第二类关节点：以改点作为生成树的非叶顶点，在生成树的原图所有的边中，该节点的儿子没有任何能回到其祖先的边。删去该节点，其子树将会脱离原来的树。

-------------------------------------
## Chapter5 Search 查找
### 基本概念
- 查找：在数据集合中寻找满足某种条件的数据对象
- 查找表：由同一类型的数据元素(或记录)组成的数据集合，没有内在的逻辑约束
- 关键字：某个数据项的值，用于表示一个数据元素
  - 主关键字：唯一标识一个数据元素的关键字
  - 次关键字：识别若干记录的关键字
- 平均查找长度ASL查找成功则ASL=$\sum(i=1,n)p_i*c_i$，其中$p_i$为查找第i个元素的概率，$c_i$为查找到该元素的平均比较次数。查找失败则ASL为总查找次数。
### 顺序查找
依次查找，直到找到元素。一般方法：数据存在数组中，查找时a[0]作为监视哨，从后往前查找。
- ASL$_{succ}$=$\sum(i=1,n) (1/n)*(n-i+1)=(n+1)/2$
- ASL$_{fail}$=n+1
- 查找复杂度O(n)
### 折半查找（二分查找）
前提：线性序列中，数据关键字有序。假设是升序。
1. low和high为查找的上界下界，中间位置mid=$\lfloor (low+high)/2\rfloor$
2. 比较mid位置的值和查找值k，相等则查找成功；若k更大，则将查找范围改为mid+1到high，否则改为low到mid-1
3. low>high则查找失败
- ASL=$\sum(j=1,h) (1/n)*(j*2^{j-1})=(n+1)*log_2(n+1)/n$，其中，h=$\lfloor log_2(n+1)\rfloor$。
- 查找复杂度O(logn)
### 分块查找
将查找表分为几块，块间有序，添加索引表，索引表按关键字有序。n个记录分为b块，每个块有s个记录，ASL=1/b*$\sum(j=1,b)j$+1/s*$\sum(i=1,s)i$=(b+s+2)/2，介于顺序查找和折半查找之间。
### 优先队列priority queue（堆Heap）
优先队列是一棵完全二叉树（故可以用线性存储方式存储，从0开始计数，用层次遍历的顺序存储，对于第i个节点，其左右儿子分别为2\*i+1和2\*i+2）。对于每一个节点，其左右儿子（若存在）的值都比该节点大（小顶堆）；同理还有大顶堆。

若某一节点及其左右儿子不满足堆的大小关系，需要使用向下调整算法（以小顶堆为例）：
```c++
void heapify(int *a,int size,int n){//n表示要调整的节点
    if(n>=size)return;
    int min = n; //min记录该节点和左右儿子节点的最小值对应的key值
    if(2*n+1<size && a[2*n+1]<a[min])min = 2*n+1;
    if(2*n+2<size && a[2*n+2]<a[min])min = 2*n+2;

    if(min==n)return;       //满足堆的性质，直接返回
    swap(a[n],a[min]);      //否则使得该节点值最小
    heapify(a,size,min);    //向下调整
}
```
对于一个序列a[n]，要使得其完全满足堆的性质，则要从后往前依次堆化节点。
```c++
void HeapStruct(int *a,int size){
    for(int i=size/2;i>=0;i--)heapify(a,size,i);
}
```
插入元素时，直接插入序列的最后，再进行向上调整算法：
```c++
void AdjustUp(int *a,int size,int n=INT_MIN){
    if(n==INTMIN)n=size/2-1;
    if(n<0)return;
    int min = n;
    if(2*n+1<size && a[2*n+1]<a[min])min = 2*n+1;
    if(2*n+2<size && a[2*n+2]<a[min])min = 2*n+2;

    if(min==n)return;           //满足堆的性质，直接返回
    swap(a[n],a[min]);          //否则使得该节点值最小
    AdjustUp(a,size,(n-1)/2);   //向上调整
}
```
删除：只允许删除根节点元素，即a[0]。将a[size-1]替换掉a[0]，再通过向下调整算法从a[0]开始重新调整。
```c++
void delete(int *a,int size){
    a[0]=a[size-1];
    heapify(a,size,0);
}
```
查找算法如下,效率为O(logn)：
```c++
int find(int *a,int size,int n,int key){
    if(n>=size || a[n]>key)return -1;   //查找失败，返回-1
    if(a[n]==key)return n;              //查找成功，返回下标
    int ans=find(a,size,2*n+1,key);     //查找左儿子
    if(ans!=-1)return ans;              //左儿子查找成功则返回
    return find(a,size,2*n+2,key);      //否则直接返回查找右儿子的值
}
```
### 散列（哈希表hash table）
将查找的键值key通过散列函数h直接映射到某一地址空间h(key)上，实现查找为常数时间O(1)。散列技术既是一种查找技术又是一种存储技术。散列是面向查找的存储结构，不能反映数据之间的逻辑结构。散列通常用于实际出现的关键字的数目远小于关键字所有可能取值的数量，不适用于允许多个记录有同样关键字值的情况和范围查找（如查找最大关键值的记录）。构造散列有以下的基本方法：
- 直接定址法：hash(key)=a*key+b,适用于事先知道关键字的值，关键字取值集合不是很大且连续性较好的情况。
- 数字分析法：对关键字进行分析，取关键字的若干位或组合作为哈希地址。适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。
- 平方取中法：将关键字平方后取中间几位作为哈希地址。适用于事先不知道关键字的分布情况且关键字的位数不是很大的情况。 
- 折叠法：把关键字自左到右分成位数相等的几部分，每一部分的位数应与散列表地址位数相同，只有最后一部分的位数可以短一些。把这些部分的数据叠加起来，就可以得到具有该关键字的记录的散列地址。如：123456789，分别使用两种不同的叠加法，以3位进行划分：
    - 移位法：123+456+789=1368,保留三位得368
    - 分界法：123+654+789=1566,保留三位得566
- 除留余数法：hash(key)=key%p,最简单最常用
- 随机数法：H(key)=rand(key),rand不可知但是唯一，使用key长度不等

解决散列冲突：
- 开放定址法：冲突时按某种规律寻找下一个空位置
    - 线性探测法：将散列表看做循环表，冲突时按次序往后找首个空位置插入。若是查找，找不到记录则依次往后查找，找到空位置或经过依次循环则查找失败。
        - 优点：表未满则必能找到插入位置
        - 缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而又增加了更多的冲突机会(这种现象称为冲突的聚集)
    - 二次探测法：在位置pos失败后，依次探测pos+1<sup>2</sup>,pos+2<sup>2</sup>,pos+3<sup>2</sup>...（注意不要超出范围） 
        - 优点：探测序列跳跃式地散列到整个表中，不易 产生冲突的“聚集”现象
        - 缺点：不能保证探测到散列表的所有地址
    - 伪随机探测法：增量函数为伪随机函数
- 再哈希法：使用多个有优先关系的哈希函数，一个冲突时用下一个
    - 优点：不易产生冲突的聚集现象
    - 缺点：计算时间的增加
- 链地址法：散列地址存储的是链表头，处于同一个散列地址的元素被链表依次链接
    - 优点：不易聚集，易删除元素
- 建立公共溢出区：另外设立一个溢出表保存与基本表中记录冲突的所有记录。 

查找分析：填满因子α=表中记录数/表长
- 线性探测法:
    - ASL$_{succ}$≈(1+1/(1-α))/2
    - ASL$_{fail}$≈(1+1/(1-α)<sup>2</sup>)/2
- 二次探测、伪随机探测、再哈希法：
    - ASL$_{succ}$≈-1/α * ln(1-α)
    - ASL$_{fail}$≈1/(1-α)
- 链地址法：
    - ASL$_{succ}$≈1+α/2
    - ASL$_{fail}$≈α+e<sup>-α<sup>

---------------------------------
## Chapter6 Sorting 排序
### 基本概念
- 排序的稳定性：键值相同的元素在排序前后的先后位置不会发生改变则排序是稳定的，否则为不稳定的。
- 内/外排序：内排序的排序对象在排序时全部在内存中，外排序的排序对象太多，不能全部存入内存，只能不断在内存和外存之间移动。

**以下排序全部以升序为例**
### 插入排序Insertion Sort
1. 将a[0]作为哨兵，给第i个元素排序时，之前的序列已经完成了排序。
2. 将该元素key从后往前依次和之前元素比较，若key小于当前元素，当前元素后移一位，否则将key存入当前元素的下一位置。
3. 从1到n将整个序列处理完成。
```c++
void InsertSort(int *a,int size){
	//创建新数组arr，空出0位置的元素作为哨兵
    int *arr = new int[size+1];
	for(int i=0;i<size;i++)arr[i+1] = a[i];
	
	for(int i=1;i<=size;i++){
		arr[0] = arr[i];               //设置哨兵
		for(int j=i-1;j>=0;j--){
			if(arr[j]>arr[0])arr[j+1] = arr[j];//后移元素
			else{
				arr[j+1]=arr[0];       //找到位置后的插入
				break;
			}
		}
	}
	//将arr中的元素赋值回原数组
	for(int i=0;i<size;i++)a[i]=arr[i+1];
	delete []arr;
}
```
### 希尔排序Shell Sort
1. 将元素分数次划分为多个序列。划分方式由定义的gap决定。例如gap依次为3,2,1，其中，gap最后一个取值必须为1.
2. 若gap=3,将a[n]分为3个子序列，子序列的下标依次为：第一个序列：0,3,6,9... 第二个序列：1,4,7,10...，第三个：2,5,8,11...，每个序列进行单独的排序。
3. 选择下一个gap值，重复2的步骤，直到所有gap值被处理完。
```c++
void ShellSort(int *a,int size){
	int gap[] = {3,2,1};          //以3、2、1为例
	for(int i=0;i<3;i++){
		int n = size/gap[i];
		while(n--){
			bool flag = true;
            //对于每一个子序列使用冒泡排序
			for(int j=0;j+gap[i]<size;j+=gap[i]){
				if(a[j]>a[j+gap[i]]){
					flag = false;
					swap(a[j],a[j+gap[i]]);
				}
			}
			if(flag)break;
		}
	}
}
```
### 冒泡排序Bubble Sort
1. 从左到右依次遍历，若两个相邻元素的顺序有误则交换。
2. 重复以上步骤n-1趟。若某次遍历已经全部有序则直接跳出循环。
```c++
void ShellSort(int *a,int size){
	int n = size;
	while(n--){
		bool flag = true;       //flag为ture表示序列有序
		for(int i=0;i<size-1;i++){
			if(a[i]>a[i+1]){
				swap(a[i],a[i+1]);  //若无序，交换无序的两元素
				flag = false;       //将flag改为flase
			}
		}
		if(flag)break;              //若有序，直接退出循环
	}
}
```
### 快速排序Quick Sort
1. 在序列中选择一个值作为键值，将小于它的数全部放到其左边，大于它的数放到右边，相等则皆可。
2. 将左边和右边的两个子序列进行快速排序，直到序列长度为1。
```c++
void QuickSort(int *a,int left,int right){
	if(left>=right)return;
	int l = left,r = right;
    //选择序列第一个数作为键值，小于键值的数放在左边，大于的放右边
	while(l<r){
		while(l<r && a[l]<=a[r])r--;//找到右边小于键值的数
		if(l>=r)break;
		swap(a[l],a[r]);
		while(l<r && a[l]<=a[r])l++;//找到左边大于键值的数
		if(l>=r)break;
		swap(a[l],a[r]);
	}
    //左右部分递归调用排序
	QuickSort(a,left,l-1);
	QuickSort(a,l+1,right);
}
```
快速排序在某些较差情况会产生退化，因为键值的选取导致速度特别慢。可以取每个序列的第一个、最后一个、最中间的数，将中间值赋给键值以优化。
### 选择排序Selection Sort
1. 将序列分为“待排序”序列和“已排序”序列，后者初始时为空
2. 每次从待排序序列中选取最小值，加入已排序序列
```c++
void SelectionSort(int*a,int size){
	for(int i=0;i<size;i++){
		int min = i;            //min记录待排序序列中最小值的下标
		for(int j=i;j<size;j++){
			if(a[j]<a[min])min = j;//找到更小的值则把下标赋给min
		}
		swap(a[i],a[min]);      //将最小值放到已排序序列的尾部
	}
}
```
### 堆排序Heap Sort
1. 初始序列为堆（不为堆则进行堆化），每次选取堆顶元素加入已排序序列，并从堆中删去。
2. 将剩下的结构重新维护为一个堆。
```c++
void HeapSort(int *a,int size){
	HeapStruct(a,size);         //将数组堆化
	for(int i=size-1;i>0;i--){
		//将堆顶元素由后往前依次放入序列尾，这要求堆为大顶堆
        swap(a[0],a[i]);        
		heapify(a,i,0);
	}
} 
```
### 归并排序Merge Sort
1. 将序列拆成左右两个子序列，对子序列进行排序
2. 两个子序列都有序时，将两个子序列合并为一个有序的序列
```c++
void MergeSort(int *a,int left,int right){
	if(left>=right)return;
	int mid = (left+right)/2;
	MergeSort(a,left,mid);          //左序列排序
	MergeSort(a,mid+1,right);       //右序列排序
	int *arr = new int[right-left+1];
	int i = left,j = mid+1;
	int count = 0;
    //依次比较左右序列首个数，将最小的存入arr
	while(i<=mid && j<=right){
		if(a[i]<=a[j])arr[count++] = a[i++];
		else arr[count++] = a[j++];
	}
    //将子序列还没读完的数读入
	while(i<=mid)arr[count++] = a[i++];
	while(j<=right)arr[count++] = a[j++];
    //将arr写回原序列
	for(int i=0;i<right-left+1;i++)a[left+i] = arr[i];
	delete []arr;
}
```
### 基数排序Radix Sort
- 最高位优先法：
1. 将数字按照高位分组，每一组进行排序
2. 对于每一组，按照次高位进行排序
3. 递归处理，直到组中只有一个数据时结束
```c++
void LSDRadixSort(int *a,int digits,int&pos,vector<int>& sub){
//digits表示按第几位来进行分类，pos代表写到了a的哪个位置，初始为0，sub初始元素及顺序和a相同，表示当前处理的组
	if(sub.size()==0)return;    //组为空，直接返回
	if(sub.size()==1){
		a[pos++] = sub[0];      //组中有一个数，按顺序写入a
		return;
	}
	int num = 1;
	for(int i=1;i<digits;i++)num*=10;
	for(int i=0;i<10;i++){
		vector<int> vec;        //vec记录下一组的数据
		for(int j=0;j<sub.size();j++){  //digits位为j的数据存入vec中
			if((sub[j]/num)%10==i)vec.push_back(sub[j]);
		}
		RadixSort(a,digits-1,pos,vec);  //递归调用，位数低一位
	}
}
```
- 最低位优先法：
1.  初始序列中的每个元素的位数相同，从最低位开始到最高位依次进行2：
2.  根据该位的数据，存放到对应的队列中
3.  将按队列按照其所代表的数字的从小到大顺序排列，将元素依次写回原序列
```c++
void MSDRadixSort(int *a,int size,int digits){
    //数字的位数为digits，则从最低位一直循环到最高位
    int c = 1;
	while(c++!=1+digits){
		int num = 1,pos = c;
		while(--pos)num*=10;
		vector<int> a0,a1,a2,a3,a4,a5,a6,a7,a8,a9;
		for(int i=0;i<size;i++){
			int tmp = (a[i]/num)%10;
			switch(tmp){    //依据本位的数字，写入相应的队列中
				case 0:{a0.push_back(a[i]);break;}
				case 1:{a1.push_back(a[i]);break;}
				case 2:{a2.push_back(a[i]);break;}
				case 3:{a3.push_back(a[i]);break;}
				case 4:{a4.push_back(a[i]);break;}
				case 5:{a5.push_back(a[i]);break;}
				case 6:{a6.push_back(a[i]);break;}
				case 7:{a7.push_back(a[i]);break;}
				case 8:{a8.push_back(a[i]);break;}
				case 9:{a9.push_back(a[i]);break;}
			}
		}
        //按数组从小到大的顺序，将数据写回原数列
		int i=0;
		for(int j=0;j<a0.size();j++)a[i++]=a0[j];
		for(int j=0;j<a1.size();j++)a[i++]=a1[j];
		for(int j=0;j<a2.size();j++)a[i++]=a2[j];
		for(int j=0;j<a3.size();j++)a[i++]=a3[j];
		for(int j=0;j<a4.size();j++)a[i++]=a4[j];
		for(int j=0;j<a5.size();j++)a[i++]=a5[j];
		for(int j=0;j<a6.size();j++)a[i++]=a6[j];
		for(int j=0;j<a7.size();j++)a[i++]=a7[j];
		for(int j=0;j<a8.size();j++)a[i++]=a8[j];
		for(int j=0;j<a9.size();j++)a[i++]=a9[j];
	}
}
```
|方法|比较次数复杂度|移动次数复杂度|稳定性|空间开销|
|:-:|:-:|:-:|:-:|:-:|
|插入排序|最好n 最差n<sup>2</sup>|最好0 最差n<sup>2</sup>|√|1|
|冒泡排序|最好n 最差n<sup>2</sup>|最好0 最差n<sup>2</sup>|√|1|
|快速排序|最好nlog<sub>2</sub>n 最差n<sup>2</sup>|最好nlog<sub>2</sub>n 最差n<sup>2</sup>|x|最好nlog<sub>2</sub>n 最差n<sup>2</sup>|
|选择排序|n<sup>2</sup>|最好0 最差n|x|1|
|堆排序|nlog<sub>2</sub>n|nlog<sub>2</sub>n|x|1|
|归并排序|nlog<sub>2</sub>n|nlog<sub>2</sub>n|√|n|
-----------------------------
## 文件管理
### 基本概念
- 数据项：数据文件中的最小单位
- 记录：一个实体的所有数据项的集合。
- 关键字（项）：关键字项用来标识一个记录的数据项集合(一个或多个)，关键字项的值称为关键字
- 文件：大量性质相同的数据记录的集合
- 文件的分类
  - 按记录类型分：
    - 操作系统文件（流式文件）：连续的字符序列的集合（串）
    - 数据库文件：有特定结构(所有记录的结构都相 同)的数据记录的集合
  - 按记录长度分：
    - 定长记录文件：文件中每个记录都有固定的数据项组成，每个数据项的长度都是固定的
    - 不定长记录文件：长度不固定。
- 文件的操作
  - 检索记录
  - 插入记录：按位置和按条件
  - 删除记录
  - 修改记录
  - 记录排序
### 文件组织方式（物理结构）
- 顺序文件：记录按其在文件中的逻辑顺序依次进入存储介质。在顺序文件中，记录的逻辑顺序和存储顺序是一致的。适合于 顺序存取的外存介质，但不适合随机处理。
- 索引文件：索引是记录和记录存储地址之间的对照表。索引结构(称 为索引文件)由索引表和数据表两部分。如果数据文件中的每一个记录都有一个索引项，这种索引称为稠密索引，否则称为非稠密索引。
- ISAM（顺序索引存取方法）文件：专为磁盘存取设计的一种文件组织方式，采用静态索引结构，是一种三级索引结构的顺序文件。
- VSAM（虚拟存取方法）文件：一种索引顺序文件组织方式，利用OS的虚拟存储器功能 ，采用的是基于B+树的动态索引结构。 
-  散列文件（直接存取文件）：利用散列存储方式组织的文件。类似散列表，即根据文件中记录关键字的特点，设计一个散列函数和冲突处理方法，将记录散列到存储介质上。
- 多关键字文件：数据库文件常常是多关键字文件，多关键字文件的特点是不仅可以对主关键字进行各种查询，而且可以对次关键字进行各种查询。其分为：
  - 多重表文件：记录按主关键字的顺序构成一个串联文件(物理上的) ，并建立主关键字索引(称为主索引)；对每个次关键字都建立次关键字索引(称为次索引)，所有具有同一次关键字值的记录构成一个链表(逻辑上的)。**将具有相同关键字值的记录链接在一起，在数据文件中设有与各个关键字对应的指针域。**
  - 倒排文件（逆转表文件）：与多重表文件类似，可以处理多关键字查询。**将具有相同关键字值的记录的地址收集在一 起，并保存到相应的次关键字的索引项中，在数据文件中不设置对应的指针域。**
