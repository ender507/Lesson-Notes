# 算法设计与应用

## 1. 数字运算
### 1.1 基本算数
数字的表示、进制。

几进制的几叫做“基”base。表示整数N，以b为基，需要$\lceil log_b(N+1) \rceil$位。

如果一次算一位，加法的复杂度为O(n)，乘法为O(n^2)。这被称为位复杂度，实际程序运行时加法和乘法都看作一步到位。

AI Khwarizmi的乘法算法：x*y时，一个除以二（整数除法），一个乘二，如此反复并列竖式。去掉除以二的数为偶数的项，加和乘二的数未被去掉的项。例子：11\*13

| x    | y    | 备注                              |
| ---- | ---- | --------------------------------- |
| 11   | 13   | 11*13，原来的数字                 |
| 5    | 26   | 11/2整数除法，结果为5             |
| 2    | 52   | 因为2为偶数，最后计算时删去这一行 |
| 1    | 104  |                                   |

结果：13+26+204=143，52被删去。

```c
int multiply(int x, int y){
    if(x==0) return 0;
    z = multiply(x/2,y);
    if(y%2)return 2*z;
    else return x+2z;
}
```

这种方法以二进制的观点看，和列竖式的乘法常规算法本质相同。

### 1.2 模运算

模运算是处理特定范围内的整数的系统。 

- 替换法则：若x1 ≡ x2 (mod N)，y1 ≡ y2 (mod N)，有：
  - x1+y1 ≡ x2+y2 (mod N)
  - x1\*y1 ≡ x2\* y2 (mod N)
- 代数法则：
  - 结合律
  - 交换律
  - 分配律

#### 1.2.1 模指数运算

求解(x^y)mod N，其中x^y数字相当大。

将y看做二进制数字，每次除以二，x每次平方。若y的低位为1表示存在当前的x项，模N后乘入结果，结果再求模。基本原理：

- 幂的拆分：x^25 = x^16 * x^8 * x1
- x^2 ≡  (x%N)^2 (mod N)

```c
int modexp(x,y,n){
    if(y==0)return 1;
    z = modexp(x,y/2,N);
    if(y%2)return (z*z)%N;
    else return (x*z*z)%N
}
```

#### 1.2.2 欧几里得算法

求`gcd(a,b)`。

- 欧几里得法则：若x>y，`gcd(x,y)=gcd(x%y,y)`。

- 证明：因为x和y的公因子能除尽x和y，故除得尽x-y，即有`gcd(x,y)=gcd(x-y,y)`，而x多次减去y可以得到x%y。

```c
//默认开始时a>=b
int euclid(int a, int b){
    if(b==0)return a;
    return euclid(b, a%b);
}
```

扩展欧几里得算法：如何验证给出的d是a和b的最大公因子？

- 引理：若d可以整除a和b且`d=ax+by`则`d=gcd(a,b)`。

- 证明：整除a和b表示d为公因子，`d<=gcd(a,b)`。而`d=ax+by`若a和b的最大公因子c能整除a和b，必然也就能整除`ax+by`，即能整除d，故`d>=gcd(a,b)`，综上，d为`gcd(a,b)`

推广：存在整数x和y使得`gcd(a,b)=ax+by`

欧几里得算法的逆运算。

#### 1.2.3 模的逆modular inverse

若`ax ≡ 1 mod N`则称x为a模N的逆。对特定的a和N，逆可能不存在，若存在，x%N唯一。x记为`a^-1 mod N`。一般取逆范围为[1,N-1]

求模的逆：若a和N互质，使用欧几里得逆运算求得带参数的a和N表示1，其中a的参数即为所求。

如：求11mod25的逆，有：1=15\*25 - 34\*11，而 -34 ≡ 16 mod 25，结果为16。

### 1.3 质数检测

#### 1.3.1 费马小定理

若p是质数，则对于全部[1,p)内的整数a都有：`a^(p-1) ≡ 1 (mod p)`

证明：对任意a有集合全等：{1,2,3,...,p-1} = {a\*1mod p,a\*2mod p,...,a\*(p-1))mod p}，各自相乘有(p-1)! ≡ a^(p-1)*(p-1)! mod p，同除(p-1)!得到了费马小定理。

需要说明的是，费马小定理表述的是p为质数的必要条件而不是充分条件。对于部分合数p，若选取的a不恰当时也满足上式。此时称p为关于a的伪素数。对于小部分合数，甚至对于全部的a都满足上式，被称为卡迈尔数

可以证明，对于伪素数，a的取值使得满足上式的数绝对不会多于不满足的。换句话说，对任意非卡迈尔数的合数随机取a的话，满足上式的可能性小于等于1/2，而卡迈尔数则是1。

#### 1.3.2 生成随机质数

拉格朗日的质数定理：π(x)表示小于等于x的质数的**个数**，则$\lim_{x->\infin}\frac{\pi(x)}{x/ln(x)}=1$，即π(x)约等于x/ln(x)。这保证了质数的数量。

1. 生成随机数
2. 进行费马小定理的检验
3. 决定是否重新生成

### 1.4 密码学问题

发送方对信息`x`加密`e(x)`，接收方对信息解密`d(e(x))`，其他人只能收到加密后的信息`e(x)`。

#### 1.4.1 一次性密钥one-time pad

发送方和接收方提前约定好密钥r，通过异或密钥对信息进行加密解密。r随机取得。如果多次使用相同密钥会不安全。对于两个信息x和y，若知道x异或r和y异或r，可以求出x异或r，找到信息的相同部分。但反复使用新密钥很麻烦。

#### 1.4.2 非对称密钥：RSA密码系统

每个用户都有自己的两种密钥：公开的和私有的。发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密。

取两个很大的质数p和q，令`N=pq`，对于任意和(p-1)(q-1)互质的e，对要发送的信息x，x^e mod N是到[0,N-1]的双射。令d为e模 (p-1)(q-1)的逆，则(x^e)^d ≡ x (mod N)。N和e可以作为公钥，而d为私钥。

证明：因为d是e模(p-1)(q-1)的逆，故有正整数k满足：`ed = 1 + k(p-1)(q-1)`。依据费马小定理，对于质数p(q同理)，有：`x^(p-1) ≡ 1 (mod p)`所以`x^k(p-1) ≡ 1 (mod p)`,`x^k(q-1) ≡ 1 (mod q)`，故`x^(k(p-1)(q-1)) ≡ 1 (mod p)`，故`x^(1+k(p-1)(q-1)) ≡ x (mod p)`，q同理。又因为p和q为质数，所以mod N也满足。

### 1.5 全域哈希

每个元素通过哈希函数映射到哈希表的一个表项，一个表项可以容纳多个元素

关于哈希本身这里讲的挺浅的，详细参考数据结构与算法[关于哈希的笔记](https://github.com/ender507/Lesson-Notes/blob/master/Data Structure And Algorithm.md#散列哈希表hash-table)

以IP地址为例，以点分十进制记录。取表项个数为质数N，在[0,N-1]随机选取a1~a4，作为IP地址四个数的权值，相乘后再将四个数加和，最后模N。

全域哈希的最大特点是尽可能避免产生冲突

------------

## 2. 分治divide and conquer

问题拆分为同类型的子问题，递归减小问题规模，解决最小问题，组合子问题答案形成原问题答案

### 2.1 乘法

复数乘法`(a+bi)(c+di) = ac - bd + (bc+ad)i`，涉及四次实数乘法，但`bc+ad = (a+b)(c+d)-ac-bd`，可以化为三次乘法运算。

诸如此类减少乘法个数的例子...

### 2.2 递归关系

#### 2.2.1 master定理

$T(n)=aT(\lceil n/b \rceil) + O (n^d)$则有T(n)=：

- $O(n^d)$，若$d>log_b^a$
- $O(n^d*log(n))$，若$d=log_b^a$
- $O(n^{log_b^a})$，若$d<log_b^a$

