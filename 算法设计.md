# 算法设计与应用

我换了个markdown编辑器，和`github`一样不支持latex语法。只有非用不可的时候才用latex公式语法，其他公式我尽量使用了\`代码符\`

![哭笑](https://img4.nga.178.com/ngabbs/post/smile/ac39.png)

算法课还是玄乎。我感觉自己对各类基本算法的理解都停留在理论上，本来是想训练代码能力才选修的算法，没想到基本只是把理论又滚了一遍，最后思想还是落不了地。建议理解算法的基本思想之后去网上刷题，课程里的题太泛了，解答也只是按照算法思路过了一遍

## 1. 数字运算
### 1.1 基本算数
数字的表示、进制。

几进制的几叫做“基”base。表示整数N，以b为基，需要$\lceil log_b(N+1) \rceil$位。

如果一次算一位，加法的复杂度为O(n)，乘法为O(n^2)。这被称为位复杂度，实际程序运行时加法和乘法都看作一步到位。

AI Khwarizmi的乘法算法：x*y时，一个除以二（整数除法），一个乘二，如此反复并列竖式。去掉除以二的数为偶数的项，加和乘二的数未被去掉的项。例子：11\*13

| x    | y    | 备注                              |
| ---- | ---- | --------------------------------- |
| 11   | 13   | 11*13，原来的数字                 |
| 5    | 26   | 11/2整数除法，结果为5             |
| 2    | 52   | 因为2为偶数，最后计算时删去这一行 |
| 1    | 104  |                                   |

结果：13+26+204=143，52被删去。

```c
int multiply(int x, int y){
    if(x==0) return 0;
    z = multiply(x/2,y);
    if(y%2)return 2*z;
    else return x+2z;
}
```

这种方法以二进制的观点看，和列竖式的乘法常规算法本质相同。

### 1.2 模运算

模运算是处理特定范围内的整数的系统。 

- 替换法则：若x1 ≡ x2 (mod N)，y1 ≡ y2 (mod N)，有：
  - x1+y1 ≡ x2+y2 (mod N)
  - x1\*y1 ≡ x2\* y2 (mod N)
- 代数法则：
  - 结合律
  - 交换律
  - 分配律

#### 1.2.1 模指数运算

求解(x^y)mod N，其中x^y数字相当大。

将y看做二进制数字，每次除以二，x每次平方。若y的低位为1表示存在当前的x项，模N后乘入结果，结果再求模。基本原理：

- 幂的拆分：x^25 = x^16 * x^8 * x1
- x^2 ≡  (x%N)^2 (mod N)

```c
int modexp(x,y,n){
    if(y==0)return 1;
    z = modexp(x,y/2,N);
    if(y%2)return (z*z)%N;
    else return (x*z*z)%N
}
```

#### 1.2.2 欧几里得算法

求`gcd(a,b)`。

- 欧几里得法则：若x>y，`gcd(x,y)=gcd(x%y,y)`。

- 证明：因为x和y的公因子能除尽x和y，故除得尽x-y，即有`gcd(x,y)=gcd(x-y,y)`，而x多次减去y可以得到x%y。

```c
//默认开始时a>=b
int euclid(int a, int b){
    if(b==0)return a;
    return euclid(b, a%b);
}
```

扩展欧几里得算法：如何验证给出的d是a和b的最大公因子？

- 引理：若d可以整除a和b且`d=ax+by`则`d=gcd(a,b)`。

- 证明：整除a和b表示d为公因子，`d<=gcd(a,b)`。而`d=ax+by`若a和b的最大公因子c能整除a和b，必然也就能整除`ax+by`，即能整除d，故`d>=gcd(a,b)`，综上，d为`gcd(a,b)`

推广：存在整数x和y使得`gcd(a,b)=ax+by`

欧几里得算法的逆运算。

#### 1.2.3 模的逆modular inverse

若`ax ≡ 1 mod N`则称x为a模N的逆。对特定的a和N，逆可能不存在，若存在，x%N唯一。x记为`a^-1 mod N`。一般取逆范围为[1,N-1]

求模的逆：若a和N互质，使用欧几里得逆运算求得带参数的a和N表示1，其中a的参数即为所求。

如：求11mod25的逆，有：1=15\*25 - 34\*11，而 -34 ≡ 16 mod 25，结果为16。

### 1.3 质数检测

#### 1.3.1 费马小定理

若p是质数，则对于全部[1,p)内的整数a都有：`a^(p-1) ≡ 1 (mod p)`

证明：对任意a有集合全等：{1,2,3,...,p-1} = {a\*1mod p,a\*2mod p,...,a\*(p-1))mod p}，各自相乘有(p-1)! ≡ a^(p-1)*(p-1)! mod p，同除(p-1)!得到了费马小定理。

需要说明的是，费马小定理表述的是p为质数的必要条件而不是充分条件。对于部分合数p，若选取的a不恰当时也满足上式。此时称p为关于a的伪素数。对于小部分合数，甚至对于全部的a都满足上式，被称为卡迈尔数

可以证明，对于伪素数，a的取值使得满足上式的数绝对不会多于不满足的。换句话说，对任意非卡迈尔数的合数随机取a的话，满足上式的可能性小于等于1/2，而卡迈尔数则是1。

#### 1.3.2 生成随机质数

拉格朗日的质数定理：π(x)表示小于等于x的质数的**个数**，则$\lim_{x->\infin}\frac{\pi(x)}{x/ln(x)}=1$，即π(x)约等于x/ln(x)。这保证了质数的数量。

1. 生成随机数
2. 进行费马小定理的检验
3. 决定是否重新生成

### 1.4 密码学问题

发送方对信息`x`加密`e(x)`，接收方对信息解密`d(e(x))`，其他人只能收到加密后的信息`e(x)`。

#### 1.4.1 一次性密钥one-time pad

发送方和接收方提前约定好密钥r，通过异或密钥对信息进行加密解密。r随机取得。如果多次使用相同密钥会不安全。对于两个信息x和y，若知道x异或r和y异或r，可以求出x异或r，找到信息的相同部分。但反复使用新密钥很麻烦。

#### 1.4.2 非对称密钥：RSA密码系统

每个用户都有自己的两种密钥：公开的和私有的。发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密。

取两个很大的质数p和q，令`N=pq`，对于任意和(p-1)(q-1)互质的e，对要发送的信息x，x^e mod N是到[0,N-1]的双射。令d为e模 (p-1)(q-1)的逆，则(x^e)^d ≡ x (mod N)。N和e可以作为公钥，而d为私钥。

证明：因为d是e模(p-1)(q-1)的逆，故有正整数k满足：`ed = 1 + k(p-1)(q-1)`。依据费马小定理，对于质数p(q同理)，有：`x^(p-1) ≡ 1 (mod p)`所以`x^k(p-1) ≡ 1 (mod p)`,`x^k(q-1) ≡ 1 (mod q)`，故`x^(k(p-1)(q-1)) ≡ 1 (mod p)`，故`x^(1+k(p-1)(q-1)) ≡ x (mod p)`，q同理。又因为p和q为质数，所以mod N也满足。

### 1.5 全域哈希

每个元素通过哈希函数映射到哈希表的一个表项，一个表项可以容纳多个元素

关于哈希本身这里讲的挺浅的，详细参考数据结构与算法[关于哈希的笔记](https://github.com/ender507/Lesson-Notes/blob/master/Data Structure And Algorithm.md#散列哈希表hash-table)

以IP地址为例，以点分十进制记录。取表项个数为质数N，在[0,N-1]随机选取a1~a4，作为IP地址四个数的权值，相乘后再将四个数加和，最后模N。

全域哈希的最大特点是尽可能避免产生冲突

------------

## 2. 分治divide and conquer

问题拆分为同类型的子问题，递归减小问题规模，解决最小问题，组合子问题答案形成原问题答案

### 2.1 乘法

复数乘法`(a+bi)(c+di) = ac - bd + (bc+ad)i`，涉及四次实数乘法，但`bc+ad = (a+b)(c+d)-ac-bd`，可以化为三次乘法运算。

诸如此类减少乘法个数的例子...

### 2.2 递归关系**Recurrence** relations

####  master定理

$T(n)=aT(\lceil n/b \rceil) + O (n^d)$则有T(n)=：

- $O(n^d)$，若$d>log_b^a$
- $O(n^d*log(n))$，若$d=log_b^a$
- $O(n^{log_b^a})$，若$d<log_b^a$

### 2.3 归并排序

具体做法的[笔记](https://github.com/ender507/Lesson-Notes/blob/master/数据结构与算法.md#归并排序merge-sort)

`F(n) = 2*F(n/2) + O(n)`

可以证明，O(n*log(n)）是排序算法的最坏时间复杂度的下限

### 2.4 中位数median

找一个序列中第k小的数字。

对任何一个元素v，原序列S可以分成三份：

- 比v小的子序列`Sl`
- 和v相等的子序列`Sv`
- 比v大的子序列`Sr`

那么第k小的元素可能出现的位置：

- 若k小于等于`Sl`中元素的数量，则要找的元素在`Sl`中
- 若k大于`Sl`中元素的数量、小于等于`Sv+Sl`元素的数量，则要找的元素就是v
- 若k大于`Sv+Sl`元素的数量，则要找的元素在`Sr`中

每次v最好能取到中位数，但序列是无序的，故v取随机一个元素的值。`F(n)=F(n/2)+O(n)`

最好情况每次对半分，时间复杂度O(n)，最差v每次取到最大或最小元素，时间复杂度O(n^2)。平均为O(n)。

### 2.5 矩阵乘法

一般算法中，将每个矩阵划成四个子矩阵，共8个。`F(n) = 8T(n/2) + O(n^2)`，复杂度为`O(n^3)`

Strassen算法中通过合理计算中间值，使得`F(n) = 8T(n/2) + O(n^2)`，复杂度$O(n^{log_27})$约为O(n^2.81)

### 2.6 快速排序

具体做法的[笔记](https://github.com/ender507/Lesson-Notes/blob/master/数据结构与算法.md#快速排序quick-sort)。虽然都学过了但是主要还是学习思想吧。

最好`O(nlogn)`,最坏O(n^2)，平均`O(nlogn)`

### 2.7 线性时间排序

插入排序（最好情况为O(n)）

计数排序counting sort：将要排序的元素作为下标，存在辅助数组里，辅助数组记录小于等于该下标元素的个数。最后下标从小到大依次从辅助数组中看元素个数。如：

1. 数列1、2、2、3、3、2，则辅助数组A[1]=1，A[2]=3，A[3]=2
2. 更新辅助数组`A[i]=A[i]+A[i-1]`，辅助数组`A[i]`表示小于等于`i`的元素个数
3. 遍历原数组，比如第一个数为1，而A[1]=1，故放在结果的第1个位置，第二个数为2，而A[2]=4，放在第4个位置，因为小于等于2的元素少了一个，故A[2]--。遍历后排序完成。

复杂度为O(n+k)，k为下标总个数。

如果遍历原数组从后往前则是稳定的排序。计数排序不需要进行比较。牺牲空间换取时间

```c
//假设要排序的数组中元素的范围为0~k
void countingSort(int input[], int output[], size){
    int A[k] = {0};
    for(int i=0; i<size; i++)A[input[i]]++;
    for(int i=1; i<k; i++)A[i] += A[i-1];
    for(int i=size-1; i>=0; i--){
        output[A[input[i]]] = input[i];
        A[input[i]]--;
    }
}
```

--------------

## 3. 图的分解

图的表示

- 邻接矩阵：常数级时间找边，空间换时间
- 相邻表：建立一个数组，下标表示各个节点。数组为指针，指向该节点的相邻边为元素的列表。找边时间O(n)

### 3.1 DFS

每个节点都要访问一遍，最坏情况边也要。O(|V|+|E|)

找连通子图：给节点一个属性记录属于第几个子图

有向无环图DAG： Directed acyclic graphs ，`pre num`：首次访问某节点的时间，`post num`：最后离开某节点的时间（考虑回溯时返回节点）、source节点：只有出去、sink节点：只有进来

有向图中DFS生成树，除了树里的边，剩余的边有三类：

- back边：从子节点回到祖先
- forward边：从祖先到非子女节点
- cross边：连接兄弟节点

一些引理：

- 有back边是图中有环的充要条件。

- 每条边必然指向`post num`更小的节点（因为要回溯），可以依据post大小进行拓扑排序。
- 对DAG节点拓扑排序：找到源节点（只有出去的边），进行输出并从图中删除。重复。

### 3.2 强连通子图

有向图中任意两个节点u和v都可以互通则是强连通图。任何有向图可以看成是多个强连通子图构成的DAG（将强连通子图看做一个节点的DAG）

- 从上述的DAG中的sink节点中的任意节点进行搜索，可以遍历整个所在的强连通子图

- 最大post的节点一定在上述DAG的源节点
- 若A、B是两个强连通子图，又有一条边从A连向B，则A中最大的post值大于B中最大的。因此也能由post值从大到小拓扑排序

- 将路径全部取反得到的逆图，源节点和sink节点身份互换。

综上，找到一个图里的所有强连通子图的步骤：

1. 找到源节点（post最大的节点），一定在上述DAG的源节点中
2. 取逆图，此时已经找到的DAG源节点成为了sink节点
3. 以sink节点为起点搜索，得到一个强连通子图
4. 将得到的子图删去，重复上述步骤，直到没有剩余节点

----------------------------

## 4. 图的路径

### 4.1 BFS

每个节点都要访问一遍，最坏情况边也要。O(|V|+|E|)

有了BFS的概念之后，带权图有了意义

### 4.2 Dijkstra算法

如果用堆存储各节点的信息（堆的每个节点对应图的节点，节点的排序依据为起点到当前节点的距离，需要更新。删除最短路径的节点直接从堆顶取），复杂度O((|V|+|E|)log|V|)

### 4.3 优先队列的实现

还是有[笔记](https://github.com/ender507/Lesson-Notes/blob/master/数据结构与算法.md#优先队列priority-queue堆heap)，之前学过。除了数组还可以考虑二元或多元堆实现，但是上下调整会更复杂

### 4.4 带负值边图的最短路径

 Bellman-Ford算法：对图进行|V|-1次更新，最后求的最小值必然稳定。复杂度O(|V|*|E|)

图中不能出现负环。

### 4.5 DAGs中的最短路径

有向无环图中，更新次数不需要|V|-1，只要按拓扑排序的顺序对各个节点依次更新即可。

-----------

## 5. 贪心算法

### 5.1 最小生成树

- 去掉环的一条边不破坏无向图的连通性

- n个节点的树有n-1条边
- n个节点的连通无向图有n-1条边则为树
- 无向图为树的充要条件是任何两个节点互通有且只有一条路径

由以上性质，有了Kruskal最小生成树算法：每次选择权最小且不产生环的边。这是一种贪心算法。

 最小生成树MST的分割特性：将所有节点分成两部分，连接这两部分的最小权的边一定是MST的一部分（权相同则任取一条边）。

非连续集合的具体实现可行做法：初始时每个节点看做一棵树。加入边时合并这两个节点形成新树，子节点指向父节点，根节点指向自己。用根节点表示整棵树。当加入边AB时，节点集合加入A、B两个节点，则B当父节点，A当子节点（或相反）。再加入CD边同理。每个节点有一个“阶”，叶子节点为0，没上一层就+1。此时若加入AC边，则看A和C所在树的根节点的阶，小的根节点指向大的根节点。相等时要更新阶。考虑边(u,v)能否插入，即判断加入边(u,v)是否会产生环，只要看u和v是否有同一个祖先即可。

具体代码实现，只要有一个数组记录各个节点的父节点即可。初始化为自己。

```c
//假设edge已按照权值排好了序
void kruskal(int vec[n1], pair<int,int>edge[n2]){
	int rank[n1] = {0};	//阶
    int next[n1];		// 父节点，初始化为自己
    for(int i=0; i<n1; i++)next[i] = i;
    for(int i=0; i<n2; i++){
        int src1 = srcNode(next, edge[i].first);
        int src2 = srcNode(next, edge[i].second);
        //若根节点相同表明在同一集合内，加入该边会产生环
        if(src1==src2)continue;
        if(rank[src1]==rank[src2]){
            next[src1] = src2;
            rank[src2]++;//这里可能会产生不连续的阶，如子节点阶为0，父节点为2，是正常的
        }
        else if(rank[src1]>=rank[src2])next[src2] = src1;
        else next[src2] = src1;
    }
}

//找根节点
int srcNode(int next[],int node){
    while(next[node]!=node)node = next[node];
    return node;
}
```

性质：

- 越往上阶一定越大
- 阶为k的根节点所在的树至少有2^k个节点

- 总共有n个节点的树，阶为k的节点最多有n/(2^k)个
- 不是根节点的节点不可能再成为根节点

对边排序和找根节点：O(|E|log|V|)，(log|V|和log|E|的复杂度相同)

优化：压缩树的高度，将找根节点时路过的所有节点都变为根节点的子节点（阶不变）。之后找根节点可达到O(1)

### 5.2 集合覆盖问题

引入问题：给出一个无向带权图，各个节点表示一个镇子，现在要在某些镇子盖学校，要求：

1. 各个镇子都能到达至少一个学校且距离不超过限制
2. 盖的学校尽量少

集合覆盖问题：给出一组集合，这些集合的并集能覆盖满全集。问最少几个集合可以覆盖全集。

贪心算法：每次选择能够覆盖最多还未覆盖区域的集合。未必最优。可以证明，若共有n个节点，最少k个集合全覆盖，贪心算法得出的集合个数上限为k*ln(n)

### 5.3 贪心算法的特点

最优子结构：大问题的最优由分解后的小问题的最优构成

自顶向下解决问题（DP相反）

### 5.4 背包问题Knapsack Problem

1. 0-1背包问题：n件物品，每件物品有自己的价格和重量。如何在重量限制下拿走更多价值的物品。物品是离散的。

2. 小数背包问题：物品是连续的（散装的），可带走分数形式个数的物品

问题2可以用贪心算法直接解决：物品价格/重量可以得出性价比，从大到小取，取不了为止。问题1贪心不一定找得到最优解。

### 5.5 Huffman编码

以前的[笔记](https://github.com/ender507/Lesson-Notes/blob/master/数据结构与算法.md#哈夫曼树)。

----------

## 6.  动态规划

### 6.1 装配线问题

装配一个商品需要n步，有两条装配线。每一步在两条装配线的用时不一样，从每一步之后转移到另一个装配线的时间也不一样。问最快装配一个商品的时间与路径。

### 6.2 链矩阵乘法

四个维度各不相同的矩阵相乘，可以调整乘法次序而结果不变。不同的次序需要的计算量不同。已知a\*b与b\*c的矩阵乘法要计算a\*b\*c次。

如果有A1~An共n个矩阵，以`C(i,j)`表示从`Ai`乘到`Aj`需要的最小计算量，则`C(i,j)=min(C(i,k)+C(k+1,j)+m_(i-1)*mk*mj)`，其中mi为矩阵Am的列数。

用递归的复杂度为O(n^3)。

### 6.3 背包问题

有两种问题：物品离散（连续的在贪心算法已经讨论过），且有限或无限

若物品的重量为`wi`，价值为`vi`，则取重量为w的物品的最大价值是`k(w)`，则有：

- 无限：`k(w) = max(k(w-wi) + vi)`，w从1开始递增。复杂度O(n*W)

- 有限：若有n个物品，选取范围限定在1~j（j<=n），则`k(w,j) = max(k(w-wj,j-1),k(w,j-1))`，复杂度O(n*W)

### 6.4 编辑距离

已知一个单词没有出现在字典里，如何找出字典中和它最相近（相差字母个数最少，包含需要替换的和需要增删的）的词。如，`love`和`lolpe`的编辑距离为2：插入一个l，将v改为p。

用`E(i,j)`表示单词x的前i个字母和单词y的前j个字母形成的两个单词的编辑距离，则`E(i,j)=min(1+E(i-1,j),1+E(i,j-1), (i!=j)+E(i-1,j-1) )`，x和y分别长m和n则复杂度为O(m*n)

### 6.5 最短路径问题

找图的最短路径，限制了最多经过的路径数j。

`dist(v,i)`表示，从起点到节点v，走`i`步的最短路径长。`dist(v,i) = min( dist(u,i-1)+len(u,v) )`

找任意两个节点之间的最短路径：

`dist(i,j,k)`表示从`i`到`j`，只有1~k号节点可以使用的最短距离。`dist(i,j,k)=min( dist(i,j,k-1), dist(i,k,k-1)+dist(k,j,k-1) )`，对于所有可能的k

### 6.6 旅行销售员问题

如何访问图中所有节点，路径长度最小

`C(S,j)`表示访问子图S中所有节点，以j为终点（起点固定），则`C(S,j)=min(C(S\{j},i)) + dij`

--------

## 7. 回溯算法

八皇后问题：8*8的棋盘放上八个皇后棋子，要求每颗棋子所在的行、列、斜线上不能有其他棋子。问各个棋子放哪儿。

回溯算法一般需要解决的问题是求得一个向量`x1,x2,x3,...,xn`使得该向量满足某个要求或使得某数值最大或最小化。

状态空间树：从上到下每一层的节点表示一个答案的构成部分（上述向量的一个值），不含根节点。关于树的概念：

- 解空间：所有根节点到叶节点的集合
- 问题状态：每个节点表示解决问题的一个状态

- 状态空间：从根到任意节点的路径集合
- 状态空间树：解空间构成的树
- 解solution的状态：根节点到叶节点的路径
- 答案answer状态：满足问题要求的解状态

使用DFS在树中找答案，相关概念：

- 活节点：生成的节点，有子节点但子节点还没有生成

- E节点：子节点正在生成（子状态没有讨论完）
- 死节点：子节点已经全部产生了（被排除的状态）

 

数独、子集和问题（集合的子集之和等于特定值）



------

## 8. 线性规划与规约

### 8.1 线性规划LP

找出一个解（一组变量），满足线性方程或线性不等式，同时使得给出的特定线性方程值最大或者最小。可行解图像为凸多边形（二维）

利润最大化问题

单纯形方法：从一个顶点开始，看相邻的顶点是否更优。若有，则转移到那个点并且重新判断相邻顶点是否更优（爬山过程），直到没有最优点。因为图像为凸多边形，必然当某个点没有相邻更优点时，改点为最优的。

### 8.2 规约reduction

已知问题Q的算法，要解决问题P。若用解决Q的算法能解决P则是Q到P的规约。换句话说，任意P的实例可以转换为Q的实例，通过Q的解法解决。

关于线性规划的规约：

1. 最大值转换为求最小值：加符号
2. 小于等于变等于：更小的部分加上松弛变量
3. 等式变不等式：等于边大于等于和小于等于
4. 解x拆分为两部分x+和x-。x为二者之差

由此，将所有线性规划问题变成标准形式统一解决。

### 8.3 网络流问题

带权有向图，有起点到终点，权表示最大流量。求从前到终点的流量最大值。

最大流算法：每次选取一条路径，达到该路径的最大流，从原图中删去该路径（没达到最大流的边则减去相应权值），重复选取新路径达到最大流，直到从起点到终点没有路径为止。可能将路径堵死从而得不出最优解。

网络流向线性规划的规约：边的权值为限制，流量为要求最大值的变量

改进最大流算法：可以取消已经存在的流。加入反向流，允许反向走。如一条边初始的权值为5，反向权值为0。如果某次选择路径，需要该边2的流量，则权值变为5-2=3，反向的为2。之后找路径时，可以反向走，且反向最大流量为2。O(|V|*|E|^2)

分割定理：原流量图的一个分割切过的边的流量和（从一边流向另一边的流量）大于等于最大流。流最小的分割方法得到的流量等于最大流。

配对问题：有一些A类节点，连接1个或多个B类节点，一些B类节点同样连着1个或多个A类节点。选择一条路径连接AB节点各一个称为“配对”，一个节点最多配对一次。在图中如何选择配对路径，使得尽量出现更多的配对节点

规约为最大流问题：起点连接所有A节点，B节点最后全部汇入终点，所有A和B之间的边的权值为1.

### 8.4 对偶Duality

如x1+x2<=200，2x1+3x2<=300，第一个式子*2+第二个式子有：4x1+5x2<=700，这就是一种对偶。如果要求4x1+5x2的最值，可以由此进行检验。左边和求解函数一样，右边为上界。问题在于如何最小化右边的值。

现有：

- x1<=200

- x2<=300
- x1+x2<=400
- x1,x2>=0

求：x1+6x2的最大值，将前三个不等式分别乘以y1、y2、y3再相加，有：

(y1+y3)x1+(y2+y3)x2<=200y1+300y2+400y3，其中y1,y2,y3>=0

考虑到求解的函数，又令：

- y1+y3>=1
- y2+y3>=6

问题就在于在这些条件下如何让200y1+300y2+400y3最小，此时就得到了一个新的LP问题。而这个最优解正是原问题的最优解。两个目标函数分别最大和最小，最终求得同一个解，这就是对偶的体现。

对偶性定理：一个LP问题有解，则必然有对偶问题有相同的解。

### 8.5 零和博弈zero-one game

石头剪刀布，平局都不变，否则胜者加1分，败者减1分。分数总和为0。两个人出石头剪刀布的可能性（策略）分别(x1,x2,x3)(y1,y2,y3)，则每种情况出现的概率可以算出来。如果一个人的策略是随机策略(1/3,1/3,1/3)，另一个人策略不论如何，都是不会改变数学期望结果的，都为0。但是这是因为锤子剪刀布的高度对称性得出的结果。

很多情况下，得知对方策略并改变自己的策略能够改变结果期望。自己的策略有时只选择特定方案，如（1，0，0），称为纯策略。

将期望结果视作(x1,x2,x3,...)的函数，可以规约为LP问题。双方反复根据对方策略制定新粗略，使得结果最终稳定到一个定值。这是一种对偶的体现。s

### 8.6 单纯形算法

v为可信区域的顶点，则反复找更优的相邻顶点。

一个顶点是由n个不等式确定的，和该顶点相同的n-1个不等式和另一不等式确定的就是其邻居。

如果要求：

- 求max(c^T*x)
- Ax<=b
- x>=0
- 其中x、b、c为列向量，A为矩阵

如果原点满足条件，则原点一定是一个顶点。如果零点最优，c中元素必然全部小于等于0（前提是b大于0）。

通用解法：

- 若原点在范围内，则初始节点选为原点
- 向某个方向移动，知道移动不了为止
- 此时令当前节点为原点，重复以上步骤（比如，若当前限制条件为x1>=0，-x1+x2<=3，则新坐标原点为y1=x1，y2=3+x1-x2，这样就有新坐标下的y1>=0，y2>=0）
- 若原点最优则解决(此时要求最大值的方程的未知数的参数都为负数)

特殊情况：

- 退化：发现邻居的点的函数值和自己相同，如果转移到邻居则会陷入死循环，可以在邻居周围微量调整坐标看坐标变换情况是否更优
- 无界：合适时终止

单纯形算法运行时间：n个变量，m个限制条件。每个点最多有n*m个邻居。每次循环为O((m+n)n)。最多循环次数为C(n,m+n)

## 9. NP完全性问题

### 9.1 不可决策（判断）问题

不能设计算法的、单纯的yes/no的问题，如：

- 邮件通讯问题：每种卡片有两个字符串（A串和B串），给定卡片种类，能否排列任意张任意卡片使得排列后卡片组合的A串和B串相同？
- 停机问题：能否写一个程序检测另一个程序是否能够停机

### 9.2 算法相关

算法的重要性：横向比较算法复杂度拉开的差距、硬件优化与算法优化的比较

### 9.3 搜索问题

如何用多项式复杂度解决指数型的搜索问题

满足性问题：对一组布尔型变量组成的判断式，是否使得结果为真、旅行销售员问题：图上经过每一个节点最后回来的开销是否大于预算

### 9.4 NP=P?

有的问题不能通过推导得出，如从小到大找质数。如果能够在多项式时间内找到答案则为P问题，如果验证某个答案是否正确为多项式时间则为NP问题。如果一些NP问题都能在多项式时间内规约到某个NP个问题，且这个NP问题为多项式时间内可解的，则这些问题都在多项式时间内可解，被称为NP完全问题（NPC）。如果规约到的不是一个NP问题，则这些问题被称为NP难问题（NPH）