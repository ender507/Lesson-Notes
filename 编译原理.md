# 编译原理

## 一、 编译器介绍

### 1.1 前言

本课程的意义，编程语言的实现与应用，包括词法分析、语法分析、语义分析、运行时环境和代码生成。涉及到：

- 如何建立编程语言
- 编程语言的运作方式
- 程序行为的理解
- 语言设计的权衡
- 表达能力
- 建立大型可靠系统
- 了解基础计算机科学的概念和应用

### 1.2 语言处理过程

编译器是把一种语言翻译成另一种语言的计算机程序，一般来说源语言为高级语言，目标语言为目标机器的目标码，比如机器码或者汇编语言。

解释器和编译器都是语言实现系统，但是二者有区别：

- 解释器在翻译时就会执行源语言，按照语言的原样执行而几乎不预处理
- 编译器生成造翻译后才会被执行的目标码，需要做大量预处理

基本的高级语言处理过程为：预处理、编译、汇编、链接

### 1.3 编程语言的发展

机器语言->汇编语言->高级语言，历史balabala

### 1.4 编译器结构

- 词法分析lexical analysis（扫描scanning）：识别描述的逻辑部分
- 语法分析syntax analysis（解析parsing）：识别各个逻辑部分的连接方式
- 语义分析semantic analysis：决定整个结构的意思
- IR生成：设计一种个可能的结构
- IR优化：简化预期的结构

- 代码生成：装配上述结构
- 优化：优化结果结构

前4项被称为前端，后3项称为后端。

词法分析将语言拆成一个个的词，可以是逻辑单词、标识符、单个标点等，每一份被称为一个token。语法分析将这些token连接成一棵语法树。语义分析给语法树加上注释，表示每一个节点的类型。IR生成产生中间代码，IR优化优化中间代码的结构，代码生成产生目标码，再进行进一步的优化。

在整个编译过程中还需要其他的辅助组件，如文法表、符号表、错误处理器等。

### 1.5 编译器结构的其他方面

交叉编译：在一个平台上生成另一个平台上的可执行代码。平台包括体系结构和操作系统。

--------

## 二、 词法分析

写好的源程序的本质是字符序列，词法分析器将其转换为token的序列。token是带有附加信息的字符串。类别信息时包括在token中的基本信息。语法分析器每次从词法分析器中取得一个token，对不同类型的token进行不同的处理。

词法分析器的问题主要就是两点：如何识别出单个token、如何确定该token的类别属性。为了方便定于，需要形式化的语言对token的字符串进行描述。

### 2.1 字符串和语言

字母表alphabet是由字符组成的有限集合，字母表$\Sigma$上的语言language，是由$\Sigma$中的字符组成的字符串的集合。如$\Sigma=\{0,1\}$，那么$\{001,100100\}$,$\{\}$,$\{1,11,111,1111,...\}$都是定义在字母表$\Sigma$上的语言。空字符的语言记为$\epsilon$

语言是一种集合，因此可以应用集合的运算：

- 并union：$L\cup M=\{s|s\in L \or s\in M\}$
- 拼接concatenation：$LM=\{st|s\in L\and t\in M\}$
- 克林闭包Kleene closure：$L^*=\cup^\infin_{i=0}L^i$
- 正闭包positive closure：$L^+=\cup^\infin_{i=1}L^i$

### 2.2 正则语言regular language

一元运算符\*具有最高优先级，连接运算符次高，或|运算符优先级最低。上述运算符都是左结合的。可以被正则表达式定义的语言成为正则集，如果两个正则表达式表示同样的正则集则说他们是等价的，可以用等号连接这两个表达式。

乔姆斯基层次结构：

- 0型语言：可计算枚举语言
- 1型语言：上下文相关语言
- 2型语言：上下文无关语言
- 3型语言：正则

### 2.3 NFA和DFA

####  2.3.1 概念

我们的目标是让计算机识别正则语言。

非确定有限自动机NFA包括：

- 有限状态集S
- 输入字符集合$\Sigma$，即输入语言的字母表。一般认为$\epsilon$不算在$\Sigma$的成员中
- 每个状态都给出了翻译方法，以及对每种符号与空字符都给出了下一个状态
- 初始状态$s_0$
- 结束状态集合F（结束状态可能不止一种）

通过某种路径，从初始状态到达结束状态，则认为该语言被NFA定义或称被NFA接受。带$\epsilon$的边用于拓展可选路径。

确定有限自动机DFA是NFA的一种特例，满足：

- 没有任何含$\epsilon$的边
- 对每种状态和符号，都只有一条边可以被确定

基于DFA的识别算法：

```cpp
// 检查输入的字符串是否满足DFA，复杂度和输入字符串的长度一致
s = s0;
c = nextChar();
while(c != EOF){
    s = move(s,c);
    c = nextChar();
}
if(s in F)return true;
else return false;
```

因此，我们需要将正则表达式转换成NFA，再将NFA转换为DFA，DFA就能检测语言是否满足正则。

#### 2.3.2 从正则表达式到NFA

定义两种最简单的情况：

- 正则为空，则从初始状态经过$\epsilon$到终止状态
- 正则为单个字符，则从初始状态经过该字符到终止状态

假定$N(s)$和$N(t)$是NFA的部分，用来表示正则表达式的s和t，则可以构造：

- 如果$r=s|t$，那么$N(r)$表示为：初始状态经过$\epsilon$到$N(s)$或者$N(t)$，二者又通过$\epsilon$到中止状态
- 如果$r=st$，那么$N(r)$表示为：起始状态经$N(s)$到中间状态，再经$N(t)$终止
- 如果$r=s*$，那么起始状态可以直接经$\epsilon$到终止，或到$N(s)$。$N(s)$处理后经$\epsilon$重新回到$N(s)$起始处或到终止状态

#### 2.3.4 从NFA到DFA

定义$\epsilon$闭包$\epsilon-closure(s)$为从NFA的状态s经过$\epsilon$的边可以到达的所有状态的集合（可以走不止一步，包括s本身）。将s换成集合T则将集合中所有状态得到的结果进行并集操作。

定义$move(T,a)$表示从状态集合T中所有状态经过a的边可以到达的所有状态的集合（只走一步，不包括T中状态自身）

有如下算法将NFA转换为DFA：

```cpp
// 输入：N（NFA）；输出：D（DFA）
// 对每个NFA中的状态D，该算法都会构造一个转换表Dtran

Dstates = {epsilon-closure(s0)}; // Dstates初始化为初始状态的epsilon闭包，且该闭包未标记
while(Dstates 中含有为标记的状态集合 T){
    标记T;
    for 每种可能输入的字符a in T{
        U = epsilon-closure(move(T,a));
        if (U not in Dstates)
            将U加入Dstates，未标记;
        Dtran[T,a] = U;
    }
}
```

注意`Dstates`是NFA状态集合的集合。每个**NFA的状态集合**T表示**DFA的一种状态**，该状态到达的U为下一个状态。

下面的算法用来计算状态集合T的$\epsilon$闭包：

```cpp
将 T 的所有状态入栈;
初始化闭包为T本身;
while(栈不空){
    t = stack.pop();
    for 每个从t经epsilon能到达的状态u
        if u 不在闭包中{
            将u加入闭包;
            u入栈;
        }
}
```

可以证明，DFA、NFA和正则表达式的表达能力是一样的。转换有时会产生大量额外开销，所以有时也直接用NFA。

#### 2.3.5 DFA的优化

让DFA的状态数最少。如果字符串x区分了状态s和t，则说明s和t中有且只有一个从s经x的边到t需要经过终止状态。

最小化DFA算法：

- 初始化：集合的集合$Pi$包含两个组：终止状态集合F和其他状态S-F的集合
- 迭代更新状态直至收敛：

```cpp
for 每个组G in Pi{
	将G分成多个子组，保证对所有的a，每个子组中的任意两个状态s和t都可以经过a到同一Pi中的组;
    //最坏情况下，单个状态为一组
	将Pi中的G用子组替代;
}
```

- 选择每个组中的一个状态作为组的代表，用于得到最小DFA，记为D'
  - D'的状态是包含D的起始状态的组的代表
  - D'终止状态是包含D的终止状态的组的代表
  - 如果一个组中的状态不能通过一个字符到达另外同一个状态，该组需要分裂

可以看看[这里的例子](https://blog.csdn.net/qq_40294512/article/details/89004777)

### 2.4 从正则不经NFA到DFA

考虑用位置的集合来表示状态。如正则表达式`(a|b)*abb`，将从左到右的字母表中的字符`ababb`标上1~5的位置，用位置的集合来表示状态。在正则的末端加上`#`表示结束，从而能够构造正则的语法树。每个可以标记位置的字符都在叶子上。

定义：

- `nullable(n)`为布尔值，表示将语法树的节点n作为根节点的子树形成的子表达式是否可以表达$\epsilon$（即$\epsilon$是否满足该子正则表达式）
- `firstpos(n)`：以n为根节点的子树中，所有可以作为可识别字符的开头字符的所有叶子节点的位置集合（如`(a|b)*abb`中的`(a|b)*a`，可以识别的字符串中，可以以第一个a开头、可以以第一个b开头，可以以第二个a开头，因此结果为$\{1,2,3\}$）

- `lastpos(n)`：和上述定义类似，但是最后一个字符的位置集合。如上述`(a|b)*a`，必须以第二个a作为结尾，因此结果为$\{3\}$

- `followpos(p)`：对一个位置p，可以到达的下一个位置的集合（可能包含自己）

这些函数值的计算可以通过递归进行：

| 节点类型               | `nullable`                     | `firstpos`                                                   |
| ---------------------- | ------------------------------ | ------------------------------------------------------------ |
| 为$\epsilon$的叶子节点 | true                           | $\empty$                                                     |
| 为$i$的叶子节点        | false                          | $\{i\}$                                                      |
| 或节点$n=c_1|c_2$      | `nullable(c1)`或`nullable(c2)` | `firstpos(c1)`和`firstpos(c2)`的并集                         |
| 连接节点$n=c_1c_2$     | `nullable(c1)`与`nullable(c2)` | 如果有`nullable(c1)`则为`firstpos(c1)`和`firstpos(c2)`的并集，否则为`firstpos(c1)` |
| 星节点$n=c^*$          | true                           | `firstpos(c1)`                                               |

计算`followpos`的法则：

- 如果n是连接节点$n=c_1c_2$，那么每个`lastpos(c1)`中的位置`i`的`followpos(i)`包含`firstpos(c2)`的全部节点位置
- 如果n是星节点，则每个`lastpos(n)`中的位置`i`的`followpos(i)`包含`firstpos(n)`的全部节点位置

得到了每个位置的`followpos`的表后，可以得到一个有向图。

```cpp
// 正则到DFA的转换算法
// 输入：正则表达式r
// 输出：DFA，名为D
初始化Dstates，包含未标记的状态firstpos(n0)，其中n0为语法树的根节点;
while(Dstates存在未标记的状态S){
    标记S;
    for 每个可能的输入字符a{
        令U为followpos(p)的并集，p为S中的所有与a相关的状态;
        if(U not in Dstates)
            将U加入Dstates，未标记;
        Dstran[S,a] = U;
    }
}
```

### 2.5 正规文法

#### 2.5.1 定义

正规文法是左线性文法和右线性文法的统称，他们都是Chomsky分类下的3型文法。由正规文法产生的语言称为正规集，这种语言的结构可以用正规式来描述。

控制流图CFG是有向图$G=(N,E,n_{entry},n_{exit})$，其中N是节点集合，E是边的集合，后面分别是入口和出口节点。具有唯一的起始结点START和唯一的终止结点STOP。CFG中的每个结点至多只能有两个直接后继。对于有两个直接后继的结点v,其出边具有属性T或F，并且在CFG中的任意结点N，均存在一条从START经N到达STOP的路径。

现有文法$G[S]=(VN，VT，P，S)$为CFG，若P中的产生式有如下形式：
$$
A\to aB或A\to a(A,B\in VN,a\in VT+)
$$
则称G为右线性文法。如果产生式为如下形式：
$$
A\to Ba或A\to a(A,B\in VN,a\in VT+)
$$
则为左线性文法。

在实际的状态转换图中，右线性文法的$A\to aB$表现为A通过a边到B、$A\to a$表现为A通过a到终结状态；左线性文法中的$A\to Ba$表现为B通过a到A、$A\to a$表现为初态通过a到A。可以[参考这里](https://blog.csdn.net/Greepex/article/details/80771975)

#### 2.5.2 等价性

从接受语言的范围来说，DFA、NFA、正则表达式、正规文法都是等价的。

定理：设$r$为一个正规表达式，那么就存在一个带$\epsilon$转换的NFA接受$L(r)$。可以用数学归纳法证明：

- 基本情形：当r中运算符个数为0，r只可能是$\empty$、$\epsilon$或单个字母a，三者都有可以接受的NFA

- 归纳步：当r中含有不多于k个运算符成立时，新增一个运算符。r的最外层运算为+、为连接时、为Kleene闭包时都有等价的NFA

#### 2.5.3 转换

NFA($M=(Q,\Sigma,\delta,q_0,F)$)转右线性文法：

- 如果$(q,a)\to p$则$q\to ap$
- 如果$(q,a)\to p$且$p\in F$则$q\to a$
- 如果$q_0$为终结状态，则$q_0\to \epsilon$

右线性文法转正则式：

1. 将文法中的各个变量看做未知正则表达式，终极符号看做已知正则表达式
2. 对某个变量A，若以A为左部的全部产生式为：

$$
A\to xB|yC|zD
$$

其中x、y、z是终极符号串，则得到正则表达式方程：
$$
A=xB+yC+zD
$$

3. 整个右线性文法变换为一个正则式方程组，解出来得到等价正则表达式

NFA转换为正则式：先转换为右线性文法再转换为正则式

左线性文法转右线性文法：

- $A\to aB\Rightarrow B\to Aa$
- $A\to a\Rightarrow S\to Aa$
- $A\to \epsilon\Rightarrow S\to A$
- $S\to Aa\Rightarrow A\to a$
- $S\to A\Rightarrow A\to \epsilon$

-------

## 三、 语法分析

### 3.1 一些定义

语法分析要解决：

- 从词法分析中获得每个token，确定其在语句中或程序中扮演什么角色，如数字可能是运算数、数组下标、循环次数等
- 检查语句或程序是否符合程序语言的语法

所以先要确定程序包含的语法成分依据语法成构成程序的方法。需要精确的定义。

上下文无关语法CFG包含：

- 终端符号集合T
- 非终端符号集合N
- 唯一的开始符号S，属于集合N
- 若干$X\to Y_1Y_2...Y_n$形式的产生式，其中$X\in N$且$Y_i\in T\cup N\cup\{\epsilon\}$

推导：从开始符号开始，每一步推导就是用一个产生式的右方取代左端的非终端符号。推导得到的只含有终端符号的串称为这个文法的句子，一个文法G定义的语言就是这个文法的所有句子的集合，记为L(G)。判断一个终端符号串是否符合G的语法就是判断该串是否属于L(G)。每一步都替换最左边的终端符号则为最左推导leftmost derivation，替换右边则为最右推导。

对于一个文法，存在一个句子，该句子可以构造两个不同的分析树则称该文法为二义的。需要消除文法的二义性。而存在部分文法其二义性无法消除，也没有判断上下文无关文法是否是二义的的算法。

### 3.2 自上而下的语法分析

#### 3.2.1 语言匹配

判断一个字符串是否属于给定的CFG的语言：递归继承解析

```cpp
bool A(){
    选择一条A的产生式A->X1X2...Xk;
    for i = 1 to k{
        if Xi 是非终端符号 && !Xi()
            return false;
        else if Xi是终端符号{
			if Xi 等于当前输入的token t
                获取下一个token t;
            else return false;
        }
    }
    return true;
}
```

#### 3.2.2 匹配时的问题：左递归

消除左递归：$A\to A\alpha|\beta\Rightarrow A\to\beta A',A'\to\alpha A'|\epsilon$。这个步骤只消除了单步的左递归，但是没有消除多步产生的左递归。

消除左递归算法：

```cpp
按一定顺序排列非终结符A1,A2,...,An;
for each i in range(1,n){
	for each j in range(1,i-1){
		replace each production of (Ai -> Aj c)by(Ai -> d1 c|d2 c|...|dk c)
            where (Aj -> d1|d2|...|dk are all current Aj-productions)
    }
    eliminate the immediate left recursion among Ai-productions
}
```

简单来说，将所有的非自身的非终端符号代入，使得可能产生的多步左递归变成单步的，然后再使用单步左递归消除方法消除左递归。

#### 3.2.3 匹配时的问题：匹配哪一项

朴素想法：回溯。但回溯效率低下，需要更有效的算法。对于匹配算法的第一步“选择一条A的产生式`A->X1X2...Xk;`”，我们希望只有一条选择。因此考虑提前判断和提取左因子。

左因子算法：输入语法G，输出等价左因子语法。每个终端符号A，找到最长的非空前缀a。替换所有A的产生式，采用c表示所有非a开头的产生式结果。即原来的产生式为：
$$
A\to \alpha\beta_1|\alpha\beta_2|...|\alpha\beta_n|\gamma
$$


转换成：
$$
A\to\alpha A'|\gamma\\
A'\to\beta_1|\beta_2|...|\beta_n
$$


重复该步骤直到所有的产生式结果都没有共同的前缀。

如此一来能够消除具有相同前缀的项，从而在匹配时更容易找到需要的产生式结果。但是这并不能解决所有情况。还需要其他算法来解决。

进行如下定义：$FIRST(\alpha)$是$\alpha$的产生式的开头的终端符号集合，其中$\alpha$是任意的语法符号串。如果$\epsilon$也在其中则$\epsilon$也算入$FIRST(\alpha)$。比如$A\overset*\Rightarrow cy$（该符号表示经过多步推导可得），则$c$在$FIRST(A)$中。如果有$A\to\alpha|\beta$，因为之前的左因子算法，$FIRST(\alpha)$和$FIRST(\beta)$没有重合部分，因此我们只需要看下一个符号在$FIRST(\alpha)$还是$FIRST(\beta)$中，从而能够确定产生式选择哪一个。

计算$FIRST(X)$的方法：

1. 如果X是终端符号，则$FIRST(X)=\{X\}$
2. 如果X是非终端符号，设$X\to Y_1Y_2...Y_k$是产生式，如果某个$Y_i$满足$a$在$FIRST(Y_i)$中且之前的$Y_1,...Y_{i-1}$的$FIRST$都包含$\epsilon$，则$a$也在$FIRST(X)$中。如果对每个$Y_i$都有$\epsilon$在$FIRST(Y_i)$中，则$\epsilon$也在$FIRST(X)$中。
3. 如果$X\to\epsilon$，则$\epsilon$也在$FIRST(X)$中

简单来说，如果$Y_1$不存在空前缀，则$Y_1$的可能前缀就是$X$的前缀。如果存在空，则还要考虑$Y_2$，依次类推。如果空前缀出现在全部的$Y$中，则空前缀也出现在$X$的前缀中。

定义$FOLLOW(A)$是任何可能在某些句子中出现在A右边的终端符号的集合，其中A为非终端符号。如果A在某些顺序中为最右边的符号，则$\$$也在$FOLLOW(A)$中。

计算$FOLLOW(A)$的方法：


1. 在$FOLLOW(S)$中加入$\$$，其中S是起始符号，$\$$是输入结束的右终端符号。
2. 如果存在产生式$A\to \alpha B\beta$，则除了$\epsilon$外的$FIRST(\beta)$都属于$FOLLOW(B)$
3. 如果存在产生式$A\to \alpha B$或者$A\to\alpha B\beta$（$FITST(\beta)$包含$\epsilon$），则所有在$FOLLOW(A)$中的元素也在$FOLLOW(B)$中

预测解析表的构造：输入语法G，输出解析表。对每个产生式$A\to\alpha$都进行以下计算：

- 对每个在$FIRST(\alpha)$中的终端符号a，添加$A\to\alpha$到表中的$M[A,a]$项
- 如果$\epsilon$在$FIRST(\alpha)$中，对每个$FOLLOW(A)$中的终端符号b，添加$A\to\alpha$到表中$M[A,b]$。如果$\epsilon$在$FIRST(\alpha)$中且$\$$在$FOLLOW(A)$中，则$\$$的也要添加

如果在上面的过程执行完后，没有产生式在$M[A,a]$中，则$M[A,a]$为错误表项。

#### 3.2.4 LL(1)语法

一个语法G是LL(1)的，当且仅当对任何G中的产生式$A\to \alpha|\beta$，满足：

- $\alpha$和$\beta$的推导结果无论如何不会有相同的终端前缀
- $\alpha$和$\beta$最多一个可以推导出空字符
- 如果$\beta$经推导可以得到空，则$\alpha$不能推导出任何前缀在$FOLLOW(A)$中的字符

第一个L表示从字符串最左边开始扫描，第二个L表示得到的推导是最左推导。1表示向前看一个输入符号。

通过上面的步骤可以得到满足LL(1)语法的产生式，从而实现以解析表驱动的预测分析。

### 3.3 自下而上的语法分析

相较于自上而下的语法分析，自下而上可以分析更多的文法，但是实现起来更为麻烦。这种语法分析一般采用规约reduction的方法，用产生式的左边替代产生式的右边。自底向上的语法分析过程就是将只含有终端符号的输入串逐步规约到文法的起始符号。和自顶向下类似的，存在最左、最右文法的逆过程。

如果$S\Rightarrow_{rm}^{*}\alpha Aw\Rightarrow_{rm}\alpha\beta w$则称$\beta$为句型$\alpha\beta w$的句柄。其中$w$为终端符号串，$A$为非终端符号。$\alpha$和$\beta$中可以有终端符号和非终端符号。直观地来看，一个句型的句柄就是这个句型的分析树中最左那一棵有父子两代的子树的所有叶子的从左到右的排列。

#### 3.3.1 LR分析

LR(k)表示从左到右扫描输入、生成最右文法逆过程、提前读入k个符号的分析方法。其中k默认为1。

对于LR文法来说，存在项item的概念。项是产生式和额外一个产生结果的位置组成的。这个位置用点表示。比如产生式$A\to XYZ$就有四个项：$A\to\cdot XYZ$、$A\to X\cdot YZ$、$A\to XY\cdot Z$、$A\to XYZ\cdot$。当产生式为$A\to\epsilon$时，只存在一个项$A\to \cdot$。直观来看，项指明了语法分析时在给定的点上，已经看到的产生式的哪些部分。比如$A\to X\cdot YZ$表示我们已经在输入中看到了一个能够由$X$推导得到的串，并且希望接下来看到一个能从$YZ$推导得到的串。规范LR项集族能够确定一个有限自动机。

为了构造这样一个规范LR(0)项集族，定义增广文法augmented grammar。如果G是以S为开始符号的文法，那么G的增广文法G'为在G中加上新的开始符号S'和产生式$S'\to S$得到的文法。新增的产生式告诉分析器停止语法分析并接收输入的时机。

如果I是文法G的一个项集，那么I的闭包就是依据下面的规则从I构造得到的项集：

- 将I的所有项加入到I的闭包中
- 如果$A\to\alpha\cdot B\beta$在I的闭包中且$B\to\gamma$是一个产生式，如果$B\to\cdot\gamma$不在闭包中则也加入闭包，知道没有新的项可以加入闭包。即如果某个项的点的右边是B，则将B的产生式的点在最前面的项也加入闭包。

由此又有两个概念：

- 内核项：包括初始项$S'\to\cdot S$以及点不在最左边的所有项
- 非内核项：除了初始项之外的点在最左端的所有项‘

可以看到，求闭包时额外加入的项必然是非内核项。如果只保留内核项，可以用所有内核项求出闭包而不用保存闭包中所有的项。

定义GOTO函数：`GOTO(I,X)`， 其中I是一个项集，X是一个文法符号。它表示I中所有形如$\{A\to\alpha\cdot X\beta\}$的项的集合的闭包。简单来说，GOTO函数定义了一个文法的LR(0)自动机中的转换。自动机的状态对应项集，GOTO函数表示输入X时从I状态切换到下一个状态。

有了增广文法G'，就可以构造SLR分析表：

1. 构造$C=\{I_0,...,I_n\}$作为G'的LR(0)项的集合
2. 通过$I_i$构造状态$i$：
   1. 如果$[A\to\alpha\cdot a\beta]$在$I_i$中且$GOTO(I_i,a)=I_j$则$ACTION[i,a]$为`shift j`其中$a$为终端符号
   2. 如果$[A\to \alpha\cdot]$在$I_i$中，则$ACTION[i,a]$到`reduce`$A\to\alpha$，a为$FOLLOW(A)$的全部内容
   3. 如果$[S'\to S\cdot]$在$I_i$中，集合$ACTION[i,\$]$到accept
3. 如果$GOTO(I_i,A=I_j)$则$GOTO[i,A]=j$
4. 所有第二步和第三步未定义的表项为到error
5. 初始状态是从包含$[S'\to\cdot S]$的项集中产生的

如果存在冲突的action则称语法不是SLR(1)的，算法不适用。不同的LR分析具有相同的LR分析程序，不同之处在于用不同的方法构造出了不同的ACTION和GOTO表。已经被读入与分析的内容被称为活前缀（可行前缀）viable profixes。

#### 3.3.2 规范LR方法

LR(1)和LR(0)基本相同，但是要修改求闭包和GOTO的过程。LR(1)得到的状态比LR(0)多得多。

#### 3.3.3 向前看LR（LALR）方法

实践中最常用，得到的表大小较小。LALR方法寻找具有相同核的LR(1)项集并将他们合并成一个项集。

---------------

## 四、 语法制导翻译

### 4.1 介绍

在语法分析的同时进行语义翻译，这一技术称为语法制导翻译。为了表示语义信息，每个上下文无关的文法符号都有语义属性，用来表示语法成分对应的语义分析，如变量的语义属性可能有变量类型、变量的值等等；每个产生式都有语义规则。

语义制导翻译既包含了语义分析，又包含了中间代码生成。

### 4.2 从例子来看语法制导定义

语法树就是操作符栈操作数栈那一套；类型结构用另一套规则同时构造。

### 4.3 生成顺序和依赖图

1. 给每个语法符号赋予属性
2. 给每个产生式定于语义规则
3. 依据分析树画出依赖图
4. 通过依赖图的拓扑排序决定生成顺序
5. 依据生成顺序执行语义规则

S属性：每个属性都是综合的，保证计算顺序与LR解析的输出顺序相同。

L属性：每个属性都是综合的或者仅仅从父节点或者兄弟节点继承，保证计算顺序与递归下降预测解析的顺序相同

### 4.4 S属性定义

只有综合属性的语法导向定义被称为S属性定义（S属性定义是一个名词，而不是“S属性的定义”）。对S属性定义的求值顺序和LR语法分析相同，只有往上。在自底向上解析时同时生成S属性定义，将语法符号的属性与解析堆栈中的位置相关联。

### 4.5 L属性定义与翻译模式

如果每个继承的属性仅依赖于其左兄弟的属性或其父节点继承的属性，那么语法导向的定义就是L属性的。支持综合属性（所以S属性定义也是L属性定义），但不能依赖任何父类的合成属性。

深度优先的生成顺序，和对语法树进行深度优先遍历的顺序相同，也是与自顶向下解析相同的顺序。

翻译模式明确规定了生成顺序，按照从左到右的深度优先顺序对语义动作执行语义动作。

- A的继承属性必须在A生成前算出来
- 动作不能引用动作右侧符号的综合属性
- 综合属性必须在计算了它引用的所有属性之后才计算

### 4.6 预测分析中的L属性定义

1. 为语法规则编写一个可能的LL(1)语法
2. 通过附加语义规则来定义L属性定义
3. 将L属性定义转换为翻译模式
4. 消除翻译模式的左递归
5. 编写递归下降预测解析器(翻译器)

### 4.7 LR分析中的L属性定义

S属性定义很容易通过LR解析来生成。在LR解析中评估L属性定义的挑战是什么?

- 并不是所有的操作都在生成式主体的最右边(后缀翻译方案)
- 继承的属性不会存储在解析栈中。

----------

## 五、 运行时

### 5.1 存储管理

典型的存储布局和分配：代码区+静态数据区+堆+栈，其中堆和栈此消彼长，堆用于程序申请分配的内存，栈用于活动记录。

- 代码区：代码区域中的地址是静态的，在执行过程中没有改变，其地址在编译过程中就已经知道了
- 数据区：静态数据区储存静态数据，堆和栈储存动态数据，三者合称数据区

寄存器：

- 通用寄存器：用于计算
- 专用寄存器：程序计数器PC、栈指针SP、段指针FP、参数指针AP等

### 5.2 栈和活动记录

调用序列calling sequence：过程调用的操作序列。包括：

- 调用序列call sequence
  - 找到参数并传递
  - 保存调用者的环境（变量、地址等）
  - 创建被调用者的环境
- 返回序列：
  - 找到回传的参数并返回
  - 释放被调用者的环境
  - 重新载入调用者的环境

静态运行时环境（如FORTRAN77）：

- 静态数据：局部和全局变量一开始就分配好空间，地址固定
- 无动态内存分配
- 可以进行过程调用，但不能递归，每个过程的活动记录都是静态分配的

基于堆栈的运行时环境：

- 处理递归调用
- 活动记录在栈中保存，称为运行时栈或调用栈
- 一个进程可以一次在栈中有多个活动记录
- 调用序列比静态环境的序列更为复杂

### 5.3 进程间通信IPC

调用序列：

1. 调用者计算实参
2. 调用者将返回地址和旧的`top_sp`存入被调用者的活动记录
3. 调用者将活动记录入栈，从而增加`top_sp`
4. 被调用者保存寄存器的值和其他状态信息
5. 被调用者初始化局部变量并开始执行

返回序列：

1. 被调用者设置返回值
2. 被调用者将活动记录出栈，从而减少`top_sp`
3. 被调用者重新载入寄存器的原值
4. 被调用者运行到状态域的返回地址
5. 调用者获取返回值，从而减少`top_sp`

### 5.4 堆管理

堆管理的关键问题是碎片化，需要同时考虑时间和空间效率。

多线程：多线程程序共享一个公共堆，每个程序必须有自己的控制堆栈。不同线程中的过程之间的通信比IPC更容易。共享堆可以用于通信。

### 5.5 垃圾回收

栈的分配和回收是自动的，而堆的分配是手动，回收是二者结合。

性能指标：

- 总体运行时间
- 空间利用：防止碎片化
- 暂停时间：对实时应用很重要
- 程序局部性：空间局部性（数组访问）和时间局部性（短期多次访问同一对象）

垃圾回收算法：

- 引用计数：记录每个内存的引用数，为0时清除
  - 简单、即时
  - 在碰到依赖关系成环的结构时不能解决
  - 依赖于计算，而不仅仅是对象的数量，从而导致较大开销
- 基于跟踪的算法：
  - Mark and Sweep：定期遍历依赖结构，清除访问不到的内存
    - 少量垃圾存在时很高效，能够解决循环引用的问题
    - 垃圾多时很低效，需要保留所有已分配对象的列表
    - 短暂暂停使得其难以应用于实时程序
    - 导致堆的碎片化
  - Mark and Compact（上一个的改进）：清除后将现有的有效内存拼凑成无空隙的
    - 避免碎片化，提高空间利用率和程序局部性
    - 开销大，特别是移动内存
  - Copying Collector（上一个的改进）：堆被划成两部分，检测到有效内存后立即复制到另一部分且紧凑排列，从而使得检测有效内存和复制同时进行
    - 更有效率，使用更广泛
    - 只有一半堆的空间可以被利用
- 短暂停算法
  - 增量垃圾收集
  - 增量可达性分析
  - 部分收集
  - 分代垃圾收集

----

## 六、语义分析和中间代码

### 6.1 介绍

中间代码表示可以增强程序的可拓展性和进行优化。静态语义分析包括类型检查、代码域、使用未初始化变量，以及参数数量匹配、`switch`和`break`等配套等等。

低级中间码表示常用三地址码：`x = y op z`，适用于与机器相关的任务，如寄存器分配和指令选择等。3地址码可能包括的地址类型：

- 变量名（源码中变量的名字）：通过指向符号表中相关条目的指针实现
- 常量：需要考虑类型转换
- 编译器生成的临时地址：用于优化和寄存器分配

实现方式：

- 四元组：每个操作用一个四元组实现，包括操作、两个运算数、一个结果，其中运算数可以是其他四元组的结果的索引
- 三元组：操作、两个运算数，其中运算数可以是其他三元组的索引
- 间接三元组：在三元组的基础上，增加一个额外的表存储结果，操作数可以索引结果表的表项

### 6.2 类型和声明

声明：

- 文字：隐式
- 变量：显式
- 其他名字：显示

强类型语言中的类型检查：

- 类型兼容性
- 类型推理
- 隐式类型转换
- 解决重载操作符

### 6.3 作业和表达式 6.4 类型检查6.5 布尔表达式

语法制导翻译实现

### 6.6 回填和控制流语句

为了一次通过的代码生成，使用回填方法。这是处理最后必须计算的初值的一般方法。

在生成一个跳转指令时，暂时不跳转到目标位置，而是将指令放入一个表中，同一个表中所有所有跳转指令的目标相同。等到能确定正确的目标标号再去填充。

------

## 七、 代码生成

### 7.1 介绍

代码生成关注指令的选择（选择合适的机器码，生成代码的速度和大小成本都应考虑在内）、寄存器的分配与赋值（充分利用）、指令排序（即指令调度）

### 7.2 目标机器的抽象

指令集：支持的指令

寻址模式：变量寻址、常量寻址、偏移寻址等等

程序和指令开销：指令开销为1+操作数寻址开销，如果操作数在寄存器则为0，否则为1（变量或内存地址）。程序开销为指令开销总和。

### 7.3 过程的实现

静态分配/栈分配

### 7.4 基础块的优化

将三地址指令形成单个基础块，构建流程图。基础块的第一条指令称为leader。找出所有leader的方法：

- 第一个三地址指令是leader
- 跳转位置的指令是leader
- 后面跟着跳转指令的指令是leader

用向后扫描在一个基本块中计算每个变量的活跃度和下次被使用的信息。活跃度表明其是否是临时变量（是的话为True），下一次被使用信息记录它下一次出现的指令。由此，我们可以构建计算的流程图。如果程序结束时某些节点不被需要且是死节点，即无意义计算，则可以删去。

### 7.5 简单的代码生成

一般来说，我们要为每个三地址码选择寄存器，即`Rx,Ry,Rz = getReg(x=y op z)`，根据寄存器描述符和地址描述符进行决策。

```pseudocode
def getReg(y){
	if y in some reg, pick Ry in them
	else if exist empty reg, pick one
	else{
		let R be a candidate and R holds v
		for each v:
			if addrDesc(v) has other location
				R is Ok
			else if v is x and x is not z
				R is Ok
			else if v not used later
				R is Ok
			else spill
		choose R with minimal spills
	}	
}
```

### 7.6 窥孔peephole优化 

检查目标指令的滑动窗(窥视孔)，用更短或更快的序列替换窥视孔内的指令序列。如删除`x=x+0`、`x=x*1`类型的指令，将`y=x*4`替换为`y=x<<2`等。

------

## 八、 代码优化

### 8.1 介绍

三个层次的优化：

- 源代码：需人为操作，但有效
- 中间码：通用且自动进行
- 目标码：依赖于机器

优化范围：

- 窥孔优化：基于滑动窗口的优化，最小范围
- 局部优化：一个基本块内的优化
- 循环优化：将循环内计算的不变量移到循环外等
- 全局优化：进程内和进程间

### 8.2 局部优化

即基本块优化，参见上文。通过基础块中的变量依赖建立依赖图，删去不必要的变量，重新构建最简单的块。

### 8.3 控制流分析和循环优化

循环是一个具有唯一条目(入口点)的强连接子图。其特征为：

- 强连接
- 单一条目，即控制流图中如果要指向该循环整体，只能指向该循环中的一个特定节点，作为该循环的唯一入口点

该条目被称为支配项。m支配n记为`m DOM n​`。支配关系具有反射性、传递性、反对称性。如果a可以直接到b且b支配a，则称a到b的边为back edge。由back edge `a->b`定义的自然循环为b节点并上所有不通过b就能到a的节点。

### 8.4 数据流分析和全局优化

我们需要全局信息记录得到的一个值的所有数据来源，从而可以知道每个数据用在了哪些地方。

我们将可能会赋值给x的值称为L值，将用到x作为操作数的运算结果称为R值。在数据流图中，如果存在d到p的路径，则称d没有在路径上被杀死。如果x在p后，则x可能由p决定。

Ud链：x的使用定义链，指示x可以到达的s

Du链：x的定义使用链，指示可以到达x的s