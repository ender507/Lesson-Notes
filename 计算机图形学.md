# 计算机图形学Computer Graphics

## 一、 欢迎进入CG的世界

吹水

CG的三大领域：

- 建模modeling：3D模型的计算机表述
- 渲染rendering：3D到2D的映射
- 动画animation

## 二、 CG的研究与产业

吹水

## 三、 图形渲染管线Graphical Rendering Pipeline

### 3.1 图形系统

现在的图形系统包括：

- 应用
- 图形库（OpenGL、Direct3D、Vulkan等）

- 图形硬件：
  - 输入设备：键鼠、手绘板等
  - 输入内容经CPU、GPU等核心处理，在帧缓冲Frame Buffer形成图像
  - 输出设备

输出设备：

- 平面显示器 
- LED发光二级管
- LCD液晶显示器
-  Plasma panels: 等离子显示器
- Electrophoretic (Electronic Ink) Display电子墨水显示（如Kindle）

### 3.2 图像的基本概念

像素：点采样，不一定是一个点或者方形。是图像显示的最小单位

数字图像：

- 二进制图像：每个像素的值取0或1
- 灰度图：取0~255
- 彩图：RGB三个通道分别取0~255，共3*8=24位

通道是特定类型的所有样本。

α通道（alpha通道）：0到1之间的值，表示**不透明度**（即α越大，越不透明）
印刷四色模式CMYK（Cyan青色，Magenta = 品红色，Yellow黄色，blacK黑色）是一种减色模式，和是加色模式的RGB模式的颜色空间有交集但也有各自的部分

图像的种类：

- 离散图像：Z^2到R的映射，数字图像处理的研究对象
- 连续图像：R^2到R的映射，真实世界的图像

vector & raster（向量和光栅）：

- 矢量图：使用显示命令驱动，放大不会变模糊
- 位图：使用像素矩阵表示，经过连续性的操作后会出现锯齿jaggles

图像：

- 基于样本的图像：对实际物体采样，如照相
- 基于几何的图像：创建几何图形以及外观属性，然后采样进行可视化

### 3.3 图形渲染管道：

1. 顶点处理：将输入的3D空间的向量投影到2D空间
2. 图形处理：连点成线
3. 光栅化：将图像光栅化，变为像素的集合
4. 片段处理：给各个像素（片段）上色
5. 帧缓冲操作：形成最终图像

-----

## 四、 变换Transformation

### 4.1 几何数学知识Geometry

#### 4.1.1 向量与矩阵

几何学研究n维空间中物体之间的关系，在CG中主要是2D和3D空间。我们希望得到最小的几何形状集，并以此为基础构造复杂的对象。

三个基本几何元素：

- 点point
- 标量scalar：以加和乘为基本操作，符合一些基本的算术公理(结合律、交换律、逆)。标量没有几何性质。
- 向量vector：有方向和长度两个属性

矢量归一化：将向量长度化为1，常用作表示方向：$\hat a=\bold a/||\bold a||$

向量点乘、叉乘（右手定则，注意叉乘不满足交换律）、矩阵乘法

笛卡尔公式：$\bold a\times \bold b=[y_az_b-y_bz_a,z_ax_b-x_az_b,x_ay_b-y_ax_b]$=
$$
\begin{pmatrix}
0 & -z_a & y_a \\
z_a & 0 & -x_a \\
-y_a & x_a & 0 \\
\end{pmatrix}
*\begin{pmatrix}
x_b \\
y_b \\
z_b \\
\end{pmatrix}
$$


#### 4.1.2 空间

最重要的数学空间是(线性linear)**向量空间**vector space。向量空间对加法和标量乘法封闭。也就是空间内任意两个向量相加得到的向量也在空间内，任意向量乘以任意标量得到的向量也在空间内。

向量没有位置，从而引入了点和坐标的概念。两个点的差是向量，向量和点的和是点。

由点和向量组成的空间为**仿射空间**Affine space。仿射空间的基本运算为向量空间的两种和上述的两种，共4种。从基本数学概念上来说，一个坐标系对应了一个仿射空间，当矢量从一个坐标系变 换到另一个坐标系时要进行线性变换 (Linear Transformation)。

两个向量或三个点确定一个平面plane

### 4.2 表示Representation

#### 4.2.1 齐次坐标

对于一组基$v_1,v_2,...,v_n$，任意一个向量可以表示为$v=a_1v_1+a_2v_2+...+a_nv_n$，则$a_1,a_2,...a_n$就能用来描述坐标。坐标系统不足以表示点，需要定义原点来表示相对位置。原点和基向量决定了一个标架frame。

考虑到向量和点的坐标难以区分，在坐标向量最后增加一个维度，0表示向量，1（非0）表示点。在三维空间中，最后一个维度记为w。这种四维向量表示三位空间点和向量的坐标称为齐次坐标Homogeneous coordinate。齐次坐标是计算机图形学计算的关键。

#### 4.2.2 坐标系转换

坐标系转换：对于两组坐标$\bold a=[a_1,a_2,a_3]^T$和$\bold b=[b_1,b_2,b_3]^T$，表示不同基$\bold v$和$\bold u$下的同一个向量或点，有：
$$
\bold v=[v_1,v_2,v_3][a_1,a_2,a_3]^T=[u_1,u_2,u_3][b_1,b_2,b_3]^T
$$
已知v在基a下的坐标，如何将v转为基b下的坐标？首先用一组基表示另一组：
$$
\bold u_1=\gamma_{11}v_1+\gamma_{12}v_2+\gamma_{13}v_3
$$

$$
\bold u_2=\gamma_{21}v_1+\gamma_{22}v_2+\gamma_{23}v_3
$$

$$
\bold u_3=\gamma_{31}v_1+\gamma_{32}v_2+\gamma_{33}v_3
$$

这些系数定义了一个矩阵：
$$
M=
\begin{pmatrix}
\gamma_{11} & \gamma_{12} & \gamma_{13} \\
\gamma_{21} & \gamma_{22} & \gamma_{23} \\
\gamma_{31} & \gamma_{32} & \gamma_{33} \\
\end{pmatrix}
$$
坐标变换：
$$
\bold a = M^T \bold b
$$
化为齐次坐标，标架分别为$(P_0,v_1,V_2,V_3)$和$(Q_0,u_1,u_2,u_3)$，除了上述的基变换方程外，还有：
$$
Q_0=\gamma_{41}v_1+\gamma_{42}v_{2}+\gamma_{43}v_3+P_0
$$
M在最下面加上这些系数，并在最右边加上列[0,0,0,1]即可。

也可以用M来直接计算坐标系的变化。

### 4.3 变换Transformation

#### 4.3.1 2D

- 放缩变换Scale，参数为负数可以镜像reflect
  $$
  \begin{bmatrix}
  x'\\
  y'\\
  \end{bmatrix}
  =
  \begin{bmatrix}
  S_x & 0\\
  0 & S_y\\
  \end{bmatrix}
  \begin{bmatrix}
  x\\
  y\\
  \end{bmatrix}
  $$

- 剪切变换Shear 
  $$
  \begin{bmatrix}
  x'\\
  y'\\
  \end{bmatrix}
  =
  \begin{bmatrix}
  1 & b\\
  0 & 1\\
  \end{bmatrix}
  \begin{bmatrix}
  x\\
  y\\
  \end{bmatrix}
  $$

- 旋转变换Rotation，$\theta$表示逆时针转动方向
  $$
  R_\theta=
  \begin{bmatrix}
  \cos\theta & -\sin\theta\\
  \sin\theta & \cos\theta\\
  \end{bmatrix}
  $$
  注意$R_{-\theta}=R^{-1}_\theta$

以上都为线性变换，可以写作矩阵与向量的乘积。

平移变换不是线性变化。为了统一，引入齐次坐标。平移和线性变换的组合称为仿射变换。

变换矩阵的逆将恢复变换。变换顺序不可交换，取逆时顺序取反。注意最右边的矩阵是最先应用的矩阵。

旋转和平移称为刚性rigid变换。对于仿射变换，直线变换后还是直线，因此只需要对点做变换。

#### 4.3.2 3D

3D空间的旋转很困难。其他的类似于2D，不再赘述。

如果只绕坐标轴旋转，有：
$$
R_x(a)=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos a & -\sin a & 0 \\
0 & \sin a & \cos a & 0 \\
0 & 0 & 0 & 1\\
\end{pmatrix}
$$

$$
R_y(a)=
\begin{pmatrix}
\cos a & 0 & \sin a & 0\\
0 & 1 & 0 & 0 \\
-\sin a & 0 & \cos a & 0\\
0 & 0 & 0 & 1\\
\end{pmatrix}
$$

$$
R_z(a)=
\begin{pmatrix}
\cos a & -\sin a & 0 & 0\\
\sin a & \cos a & 0 & 0\\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1\\
\end{pmatrix}
$$

注意绕y轴旋转的参数符号不同于其他两个。

如何绕任意直线旋转任意角度？假设直线由点p1和p2定义。考虑：将p1移动到原点，再通过沿X、Y轴旋转，把直线p1p2移动到Z轴上，再进行旋转，最后进行还原。
$$
R(\theta)=T(x_1,y_1,z_1)\cdot R^{-1}_x(a)\cdot R^{-1}_y(b)\cdot R_z(\theta)\cdot R_y(b)\cdot R_x(a)\cdot T(-x_1,-y_1,-z_1)
$$

| 变换           | 刚体变换（旋转、平移） | 线性变换(可3*3矩阵乘法表示) | 仿射变换：线性+平移 | 投影 |
| -------------- | ---------------------- | --------------------------- | ------------------- | ---- |
| 长度不变？     | T                      | F                           | F                   | F    |
| 角度不变?      | T                      | F                           | F                   | F    |
| 平行性不变？   | T                      | T                           | T                   | F    |
| 直线仍是直线？ | T                      | T                           | T                   | T    |

-------

## 五、 视图变换Viewing Transformation

### 5.1 视图变换

如何将3D场景投影到2D屏幕上，3D视图转换类似于用相机拍照。

1. 场景建模
2. 在合适位置放置摄像机
3. 照相（投影）

#### 5.1.1 视角/摄像机变换view / Camera Transformation

定义摄像头：

- 位置e
- 看的方向g
- 摄像机上方t

如果摄像头一直位于原点，上方为y轴正方向，看z的负方向，让物品围绕摄像头运动也可以达到摄像头围着物体运动的效果。每次旋转时将摄像头移到原点，通过旋转达到几个方向和坐标轴匹配即可。

#### 5.1.2 投影变换Projection Transformation

分为正交投影orthographic projection（向平面投影）和透视投影perspective projection（向点投影）。

##### 正交投影

对于面-Z，顶部为Y的摄影机，只要丢弃Z轴信息即可。同时还要翻译并放缩结果矩阵，成为2\*2\*2的、在[-1,1]^3上分布的标准方块。这个空间就是投影的空间。

##### 透视投影

在CG、美术、视觉系统中最常用，遵循近大远小、平行线不平行，收敛到一个灭点。

利用相似三角形进行变换：
$$
y'=\frac{z'}{z}y, x'=\frac{z'}{z}x
$$
这不是线性变换，但是可以用一个线性变换来分割它，然后再用除法：使用齐次坐标则
$$
\begin{bmatrix}
wx'\\
wy'\\
wz'\\
w
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 1/z' & 0
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
z\\
1
\end{bmatrix}
=
\begin{bmatrix}
x\\
y\\
z\\
z/z'
\end{bmatrix}
$$
得到：
$$
\begin{bmatrix}
x'\\
y'\\
z'\\
1
\end{bmatrix}
=
\begin{bmatrix}
\frac{x}{z}z'\\
\frac{y}{z}z'\\
z'\\
1
\end{bmatrix}
$$
视图变换可以用4*4的齐次矩阵表示。透视分割是非线性的，会导致不均匀的缩短。透视变换是线性保留的，但不是仿射变换。透视投影是不可逆的。

如何确定透视变换的平面？因为视角定在原点，可以使用投影矩形的右上角和右下角到原点的连线的夹角表示，记为fovY。也可以用投影矩形的四个坐标l、r、b、t表示。一般来说l=-r，b=-t。记矩形的宽高比为aspect ratio，有：
$$
\tan\frac{fovY}{2}=\frac{t}{|z'|}
$$

$$
aspect=r/t
$$



### 5.2 视窗变换

在MVP（模型变换、视图变换、投影变换）后，将得到的2D图像实际放到屏幕上。投影变化后的2D图像是连续的，而屏幕是一个个的离散像素点。

定义像素位置从(0,0)到(width-1, height-1)，像素坐标表示左下角的具体的点，故像素(x,y)的中心位置其实是(x+0.5,y+0.5)。这样，整个屏幕的范围才有(0,0)到(width, height)。

需要将[-1,1]^2的2D图像映射到[0, width]*[0, height]上。
$$
M_{viewport}=
\begin{pmatrix}
\frac{width}{2} & 0 & 0 & \frac{width}{2}\\
0 & \frac{height}{2} & 0 & \frac{height}{2}\\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$$

### 5.3 总结

1. 在**物体空间**画出顶点
2. 利用**模型矩阵**将顶点放在**世界空间**正确的位置（坐标系的转换）
3. 用**视图矩阵**将所有物体放在**视图空间**（镜头位置和方向的调整）
4. 用**投影矩阵**将图像映射到**屏幕空间**（投影变换）

-----

## 六、 光栅化Rasterization

### 6.1 光栅化Rasterization

#### 6.1.1 定义

显示模型要使用基本的线，多边形，填充/图案区域等，可以在两个步骤中完成:

1. 决定显示的像素，这个过程称为光栅化或扫描转换
2. 决定每个像素的颜色值

#### 6.1.2 直线光栅化

直线较好的光栅化需要：缺口少、粗细均匀、任意截取长度相等的部分对称。

##### Digital Differential Analyzer (DDA, 数值微分法)

若斜率绝对值大于1，y每次加一，算出x（增加一个斜率的倒数），若斜率绝对值小于1，x每次加一，算出y（增加一个斜率）。四舍五入。

##### Bresenham算法

在DDA中，只使用yi来计算yi+1，忽略了选择像素的信息。Bresenham算法利用该信息来约束下一个像素的位置。

加入斜率绝对值小于1，同样从(x0, y0)开始，每次x增大1计算y。第i个点为(xi, yi)，则下一个点只能是(xi+1, yi)和(xi+1, yi+1)其中的一个。
$$
y_{i+1}=mx_{i+1}+B=m(x_i+1)+B
$$

$$
d_{upper}=y_i+1-y_{i+1}=y_i+1-mx_{i+1}-B
$$

$$
d_{lower}=y_{i+1}-y_i=mx_{i+1}+B-y_i
$$

其中m表示斜率，B表示偏移。只要比较$d_{upper}$和$d_{lower}$的大小取小的一个即可。

记$p_i=\Delta x\cdot(d_{lower}-d_{upper})$经过一系列变换和化简可以得到：
$$
p_0=2\Delta y-\Delta x
$$

$$
p_i+1=
\left\{
\begin{array}{}
p_i+2\Delta y,p_i\leq0\\
p_i+2\Delta y - 2\Delta x,p_i>0
\end{array}
\right.
$$

- 若$p_i\leq0$则$(x_{i+1},y_{i+1})=(x_i+1,y_i)$
- 若$p_i>0$则$(x_{i+1},y_{i+1})=(x_i+1,y_i+1)$

#### 6.1.3 三角形光栅化

三角形是最基础的多边形，能够组成其他的多边形。三角形一定在一个平面上，容易定义内外。

凸多边形：形状内任意两点间的连线上所有的点也都在多边形内。
增量三角形遍历Incremental Triangle Traversal：画出三角形的边，一行行遍历，从起始边缘到末端边缘结束。

Edge Walking：依次更新三角形左边的线和右边的线的x值，填充这些值之间的像素，然后更新一步y，再更新y对应的左右x，重复此过程。这样会把三角形拆成两个部分。

### 6.2 混叠（走样）Aliasing

#### 6.2.1 定义

采样导致混叠。如空间欠采样导致锯齿，图形欠采样导致摩尔纹，时间欠采样导致车轮效应等。导致混叠主要原因是采样频率太低，跟不上信号频率的变化。

#### 6.2.2 混叠

如何减少混叠？

- 增加采样频率

- 防混叠antialiasing技术：使用滤波器进行模糊化、区域抽样等

-------

## 七、 隐面消除HSR

通过表现图形可见和隐藏不可见的部分以增加图像的真实感

- 对象空间方法：确定并保留没有被遮挡的部分
  - 对象视角
  - 在3D空间中进行，光栅化之前
  - 与分辨率无关
- 图像空间方法：保留距离观察者最近的部分
  - 图像精度
  - 扫描转换后，在像素级别进行操作
  - 更快，但与分辨率有关

画家算法：从远到近进行渲染，近的覆盖远的，一次画一个对象。对于深度改变的对象不能正确渲染，相交的多边形会产生问题。有时不相交的对象也会出现问题。

### 7.1 Z-Buffer算法

对每个采样点（像素）保存最近的z值。需要一个额外的缓冲来保存深度信息。帧缓存储存颜色值，深度缓存（z-buffer）存储深度。**统一标准：z为非负数**

对n个覆盖大小为常数的三角形，复杂度为O(n)。

Z-Buffer算法是最重要的可视化算法，都在GPU中实现了。

### 7.2 对象空间方法：BSP树

在摄像机坐标下，决定对象或多边形的可见性等级。在裁剪前进行。需要进行深度排序，使用画家算法或BSP树。

BSP树（二叉空间分割树）在任意视角看静态3D多边形组非常有效。画家算法的正确顺序由对多边形的二元树的遍历决定。递归地每次用一个平面将当前空间分成两个子空间，从而将一个对象分成两个部分。生成平面的二元分割树，运行时正确遍历并输出图像。

每个平面都会将空间分成一个近的和一个远的。需要依据视图决定哪个近哪个远。先遍历远的后遍历近的。每次选取一个多边形所在平面，将其他的多边形分到两个空间中。

---------

## 八、照明和着色

照明是特定表面上特定点的光线的描述，而颜色是光线离开那一点时表现的特性。知道一点的照明和表面物理特性就能决定颜色。

 ### 8.1 照明模型

给出表面上一点的决定表面颜色的因素，通过局部和全局光照来决定颜色。

- 局部光照local illumination：关注物体是如何被光源直接照明的
- 全局光照global illumination：关注物体自身和其他表面反射和传播的光

最终呈现的物体表面颜色取决于：

- 光源：位置、类型、颜色等
- 表面材质：决定了物体如何反射光
- 光线传输：光如何在场景中移动的
- 观察位置

#### 8.1.1 光照的表现

光源分为：

- 点光源：由一点向四面八方传输等量的光

  - 强度方程：$I(p_0)=[I_r(p_0),I_g(p_0),I_b(p_0)]$

  - P点的光照强度：$i(p,p_0)=\frac{1}{|p-p_0|^2}I(p_0)$，强度随距离增加而减小称为光线衰减fallout
  - 只由位置定义

- 平行光（直射光）：光线都平行

  - 照在特定平面形成的角度都相同
  - 光线不衰减
  - 可以看做距离无限远的点光源，同样只由位置定义

- 聚光spotlight：指定光线方向的点光源
  - 由位置、照射方向、照射角度定义
  - 衰减要依据相关的衰减参数

光线在物体表面的反射分为：

- 全反射specular reflection：反射时不会出现光线的散射
- 漫反射diffuse reflection：照明点向四面八方发送等量的能量
- 光泽反射glossy reflection / 混合反射mixed reflection：上述二者的结合。向四周散射的光可能因角度的不同而强度不同

#### 8.1.2 Phong光照模型（经典局部光照模型）

给定观察角度、表面法向量、光照方向（可能有多个光源）、表面参数（颜色、发光等），计算特定着色点到摄像机的光反射情况。

##### 漫反射

物体表面收到了多少的光照能量由Lambert的cosine法则决定：如果光线垂直照射物体表面，收到的能量为1，则物体倾斜时，表面收到的能量是光线方向和表面法向量方向所成角度的cos值。表面能量与观察位置无关而与表面方向有关。

当光线方向向量l和表面法向量n为单位向量时，cos值可以由二者的点积得到。漫反射光强度为漫反射系数乘以能量，即：
$$
L_d=k_d\times(I/r^2)\times \max(0,\bold n\cdot \bold l)
$$

##### 反射高光

光滑的曲面会产生高光区域，产生镜面反射。高光区域的位置受观察角度影响。

理想情况下，反射服从Snell法则：入射光、反射光和平面法向量处于同一平面，入射角等于反射角。非理想情况下，进行对物体表面的微观描述，或进行经验近似（Phone模型）：增大法向量和反射光的角度。

最终Phong模型的经验近似的公式如下：
$$
I_{specular}=K_s\times I_{light}\times(\overline v\cdot\overline r)^{n_{shiny}}
$$
其中：

- v是光照点指向观察者的单位向量
- r是理想的镜面反射方向
- K是反射系数
- I是光照强度
- n是材质发光常数，值越大越接近镜面，高光面积越小

令h为v和l的半程向量bisector，即二者的角度的平分线上的向量，$h=\frac{v+l}{||v+l||}$，则当v和r的角度相近时，h和n也很相近（用向量点乘判断是否相近）。Blinn-Phone模型使用以下的公式表示镜面反射：
$$
L_s=k_s\times (I/r^2)\times\max(0,\bold n\cdot\bold h)^p
$$

##### 环境光ambient light

现实中的环境光太难模拟，因此加入光常量模拟环境光。没有空间和角度特征，所有表面都被均等地照射。只考虑环境光，物体看起来就像剪影。反射量取决表面属性。
$$
L_a=k_a\times I_a
$$
其中I为常数。

Phong光照模型又称经验模型，它不是基于物理原理而是通过提出经验公式，进行调参来模拟光照。它需要总和环境光、漫反射和镜面反射，同一个表面考虑三种光照后叠加起来得到最终的结果。

#### 8.1.3 其他参数的影响

##### 多光源

多光源的效果是单光源效果的简单叠加（做加法），当然，环境光只要考虑一次。

##### 有色物体

考虑RGB色彩，光照强度为$I_a=(I_{ar},I_{ag},I_{ab})$，表面反射率为$k_a=(k_{ar},k_{ag},k_{ab})$，呈现的颜色为两个向量的点积$I=I_ak_a$。每个值都在0~1之间取。

物体颜色的表现体现在RGB的环境光系数和漫反射系数的设置，而镜面反射系数是不受物体颜色影响的。

### 8.2 着色Shade

着色模型利用光照模型给出决定表面上像素颜色的方法。复杂表面常用多边形阵列表示。几何信息只在多边形的顶点表示，其他位置使用差值计算。

#### 8.2.1 平面Flat着色（常量Constant着色）

多边形的各个点颜色相同，由最后一个顶点的颜色决定整个图形的颜色。整个图形只有一个法向量。

**对面着色**

#### 8.2.2 Gouraud着色

又称为强度差值着色或颜色差值着色。每个顶点有一个法向量，通过线性差值计算图形内各个位置的颜色。在光栅化阶段计算。比平面着色更好但开销更大。

顶点的法向量（单位向量）方向是该顶点参与构成的所有多边形的法向量的加和，在顶点使用光照模型计算顶点的光照信息。

三角形的重心坐标（质心坐标）：三角形的三个顶点坐标为A、B、C，三角形内任意一点P可以用$(\alpha,\beta,\gamma)$表示，其中$\alpha+\beta+\gamma=1$。如果三者都为正，则点在三角形内部。连接AP、BP、CP，将三角形分成$A_A,A_B,A_C$三个部分，有：

- $\alpha=\frac{A_A}{A_A+A_B+A_B}$
- $\beta=\frac{A_B}{A_A+A_B+A_B}$
- $\gamma=\frac{A_C}{A_A+A_B+A_B}$

当三者都为1/3时，P点位于三角形重心。面积A可以换成任意顶点性质，如纹理、法向量等。

如果高光没有落在顶点上，多边形内的高光将会被忽略。如果有，高光可能会在图形占过多的面积。

**对顶点着色**

#### 8.2.3 Phong着色

使用三个顶点的法向量，利用线性差值计算多边形内的点的法向量，由该法向量进行光照的计算结果往往更加平滑，但开销更大。

**对像素着色**

当构成三维模型的多边形越来越多，三个着色方法得到的结果也逐渐趋同。

--------

## 九、 纹理映射Texture Mapping

为了更好地模拟物体的复杂表面，而不单纯地使用大量多边形增加运算，需要使用纹理映射。这样一来，图像复杂度不影响处理的复杂性。纹理映射被硬件支持。

纹理映射的过程就是给建模的物体表面贴图的过程，本质是将一个函数映射到3维空间的过程。这个函数的域可以是一维，二维，或者三维。

### 9.1 纹理坐标可视化

将二维的纹理用坐标(u,v)表示，范围都是[0,1]。模型上的每一个顶点对应着一个纹理坐标。

纹理是一个位图图像，可以使用图像库加载图像到内存，也可以在程序中创建。纹理的像素称为纹素texels。

- 过程纹理Procedure texture：使用程序模拟物理纹路形成或材质表面
  - 只需要存储过程和参数，节省资源。通过改变参数容易获得其他的效果，具有良好的可控性
  - 只能形成部分纹理。不能生成不能用代码实现的纹理

- 纹理合成Texture synthesis：将多个纹理图像合成一张

通过表面映射函数映射模型上的点到纹理坐标，当对模型上的点进行着色时，从2D纹理中查找适当的像素，并使用它来影响最终的颜色。纹理将被拉伸和压缩以适应多边形的尺寸。

简单图像可以使用自然参数生成纹理坐标，如球$(\theta,\phi)=(\pi u,2\pi v)$，圆柱$(u,\theta)=(u,2\pi v)$，立方体等等。复杂图像只能手动指定纹理坐标。

### 9.2 纹理放缩Texture Magnification

#### 9.2.1 纹理放大

- 取最近纹素

- 双线性差值：映射点的左上、右上、左下、右下四个纹素点，先对u方向再对v方向进行线性差值运算
- 双三次插值

#### 9.2.2 纹理缩小

一个像素点对应多个纹素点。

- 超采样：有效但开销大

- 在纹素点中内取均值

#### 9.2.3 分级细化贴图Mipmap

因为大多数时候，纹理都是预先知道的，我们可以在预处理中创建不同层次的预过滤纹理。构造一个图像金字塔，在原始图像的1/2、1/4、1/8等处进行预滤波和重新采样。在光栅化过程中，计算最接近期望采样率密度的采样率的图像的编号。

D=0，为原图，D=1长和宽缩短为原来的1/2，D=2为1/4，依次类推。最小的图只有一个纹素。如果原图的大小为1个单位，则每次大小缩小1/4，最多需要的空间为：$\sum^\infin_{i=0}\frac{1}{4^i}=4/3$。

对于相邻的两个顶点，二者的x和y的差值分别为dx和dy，而两个顶点对应的两个纹素点的差值为du和dv，则：
$$
L=\max(\sqrt{(\frac{du}{dx})^2+(\frac{dv}{dx})^2}+\sqrt{(\frac{du}{dy})^2+(\frac{dv}{dy})^2})
$$

$$
D=\log_2L
$$

对于不在整数层的像素，使用三线性差值计算。

mipmap会产生一定的模糊。

#### 9.2.4 各向异性滤波Anisotropic Filterin

将原图拆分成ripmap而不是mipmap。ripmap大小各不相同，一层有多幅图。

### 9.3 纹理映射应用

- 纹理调制：将纹理与特定的颜色混合

- 光贴图light map：是黑白纹理，白色的纹素将导致底层像素看起来更亮和更有光泽，反之更暗。纹理贴图用于向表面添加细节，而光贴图用于存储预先计算的照明。这两者在运行时相乘，并缓存以提高效率。

- 凹凸贴图Bump Mapping：在着色计算前通过扰乱法向量产生凹凸的错觉。凹凸贴图保存表面的高度。尽管建模实际上表面高度相同，通过应用贴图能够着色后产生凹凸感。如果我们对表面上的每一点的法线(仅用于材质计算)进行少量的扰动，那么我们就创建了一个在形状上有微小变化的表面。
  - 令p(u,v)为凹凸贴图上的点，对于相邻点同样有：

$$
P_u=[dx/du,dy/du,dz/du],P_v=[dx/dv.dy/dv,dz/dv]
$$

$$
n=\frac{P_u\times P_v}{|P_u\times P_v|}
$$

使用凹凸函数（取代函数）d处理表面：$p'=p+d(u,v)n$，$n'=p'_u\times p'_v$

- 位移映射Displacement Mapping：位移映射将表面上的所有点沿着它们的法向量向内或向外移动$p'=p+d(p)*n$。这实际上改变了顶点，所以需要在几何处理中进行。

- 环境映射Environment Mapping：模拟复杂的，像镜子一样能反射的对象，使用纹理来捕捉物体的环境，使用表面法线计算纹理坐标。

- 立方体贴图cube map

- 纹理改变：从一幅图像中提取纹理，然后绘制到另一个图像上

-----------

## 十、 阴影Shadow

阴影不仅增加图像的真实感，而且还表示了物体的位置、表现了投影物体的几何信息、帮助理解复杂遮挡物的几何形状。

定义：

- 接收者receiver是场景中本可能被照亮但是被遮挡了的物体
- 遮挡物occluders遮挡光源
- 本影umbra是完全不能看到光源的区域
- 半影penunbra是可以看到部分光源的区域
- 阴影shadow是本影和半影的并集

阴影的种类：

- 附加阴影attached shadows：接收者的法线背向光源

- 透射阴影cast shadows：阴影落在法线面朝光源的物体上
- 自阴影self-shadows：物体的阴影投射到自身上

阴影的常识性概念是二进制状态，即一个点要么处于阴影中，要么不处于阴影中。这相当于由点光源产生的硬阴影，然而，点光源在实践中并不存在，硬阴影给图像一个相当不现实的感觉。点光源很容易在计算机图形中建模。

### 10.1 平面投影

对于平面投影，如果投影平面为y=0，光源为l，遮挡物为v，投影点为p，依据三角形相似，有：
$$
\frac{p_x-l_x}{v_x-l_x}=\frac{l_y}{l_y-v_y}
$$
即
$$
p_x=\frac{l_yv_x-l_xv_y}{l_y-v_y}
$$
同理，z坐标系上有：
$$
p_z=\frac{l_yv_z-l_zv_y}{l_y-v_y}
$$
可以写成投影矩阵M使得MV=P：
$$
M=
\begin{bmatrix}
l_y & -l_x & 0 & 0\\
0 & 0 & 0 & 0\\
0 & -l_z & l_y & 0\\
0 & -1 & 0 & l_y
\end{bmatrix}
$$
在一般情况下，阴影应该投射到的平面不是y = 0的平面。而是一个平面n*x +d = 0。同样可以计算得出：
$$
p=l-\frac{d+n\cdot l}{n\cdot(v-l)}(v-l)
$$
有：
$$
M=
\begin{bmatrix}
\bold n\cdot\bold l+d-l_xn_x & -l_xn_y & -l_xn_z & -l_xd\\
-l_yn_x & \bold n\cdot\bold l+d-l_yn_y & -l_yn_z & -l_yd\\
-l_zn_x & -l_zn_y & \bold n\cdot\bold l+d-l_zn_z & -l_zd\\
-n_x & -n_y & -n_z & \bold n\cdot\bold l
\end{bmatrix}
$$
投影阴影法的局限性:

- 只绘制环境光，不绘制漫反射和镜面反射

- 接收端必须是平面的

- 阴影必须为每一帧渲染，即使阴影不会改变

### 10.2  曲面投影

一种方法是使用生成的阴影图片作为投影贴图。从光源出发，看得见的就被照亮，否则就在阴影里。被遮挡的地方被渲染为白色背景的黑色图像（相当于将光源作为视点的2D图像中得到被遮挡部分的剪影），将该图像作为纹理，通过纹理坐标映射到被投影处。这种方法叫做**影纹理shadow texture**。缺点：产生阴影的物体不能给自己投影。

### 10.3 阴影体shadow Volume

如果遮挡物是三角形，从光源到各个顶点引射线，可以形成三角锥。被遮挡的部分的形状是一个被截断的三角锥，被称为阴影体。在阴影体内的物体就会被遮挡。对于任意一个点，从视点往该点作线段，看线段穿插了阴影体几次就能判断该点在阴影体内还是外。穿过**前面front face**计数+1，穿过**后面back face**-1，反复+1-1，看最后的值来判断是否在阴影体内。可以使用**模板缓冲Stencil Buffer**，以每个像素为单位存储整数。一般在硬件中实现了。

模板缓冲的使用：

1. 清空缓冲区
2. 只带有环境光的整个场景被绘制到帧缓冲，进而得到颜色缓冲中的颜色信息，和在深度缓冲中的深度信息
3. 关闭深度缓冲和颜色缓冲的更新，画出阴影体的前面。所有像素穿过依次前面（前面面朝视点）则模板缓冲+1
4. 画出后面（后面背朝视点），每穿过一次就-1

5. 重新渲染整个图像，模板缓冲为0的地方加入漫反射和镜面反射的成分

优点：

- 通用的图形硬件都能用，唯一的要求就是模板缓冲
- 因为它不是基于图像的方法(不像后面描述的阴影图方法)，它没有采样问题，因此到处都能产生正确、锐利的阴影

缺点：

- 性能问题
- 由于阴影体多边形的数量往往较大，且阴影体多边形往往覆盖多个像素点，使得光栅化器成为瓶颈

### 10.4 阴影图shadow map

通过深度缓冲可以记录最近的各个物体到光源视角的距离。整个图片深度信息被称为阴影图。要使用阴影图，场景会被第二次渲染，第二次才是从观察者的视角。渲染每个部分时，会在阴影图中比较：如果一个渲染点离光源的距离比阴影贴图中的值更远，那么这个点就处于阴影中。

优点：

- 多数硬件直接支持，可以用来渲染任意几何图形
- 很快。构建阴影图的开销与渲染点的数量成线性关系，而访问时间是常数

缺点：

- 只能生成硬阴影
- 阴影质量取决于阴影图的分辨率
- 浮点深度值的相等性比较，涉及尺度、偏差、容错等问题。如果太精细，平面上也会产生阴影，如果太粗糙，阴影质量不好

阴影图和阴影体是目前使用最广泛的阴影生成方法(尤其是阴影图使用得更多)，两种技术都有自己的拓展。

----------------

## 十一、 光线追踪Ray Tracing

着色不能很好地处理全局效果，如阴影（特别是软阴影），以及光线折射或反射多于一次的情形（如玻璃制品的光泽反射）。着色方法很快但是质量很低；光线追踪效果很好但是很慢。一般来说，着色用于实时渲染，光线追踪用于线下渲染。

光线可以被解释为在场景中从光源开始并在物体周围反弹(反射和折射等)的光线的集合。光线追踪基于以下假设（尽管在真实世界中是错的）：

- 光线沿直线传播
- 相交光线不会互相影响

- 光线是从光源出发，经过一定路径后进入视线的

### 11.1 光追的基本思想

可以把帧缓冲看作是一个简单的像素矩阵，眼睛可以通过它看到场景。从眼睛投射的光线通过像素中心进入场景，它的路径被追踪以判断光线首先与哪个物体相交。在相交点与光源连线。通过遮挡关系计算像素颜色。

递归式光追：在相交的物体处产生反射光和折射光，反射光进一步寻找第一个相交的物体的点、折射光寻找出去当前物体的点和穿出后第一个相交的物体的点，这些点也和光源连线，计算颜色。若被阻挡则直接排除。

### 11.2 光线-表面相交的表示

光线由原点$R_0$和方向向量$R_d$表示：$P(t)=R_0+t*R_d$，t的值决定了射线到达的点，值总是大于0。

- 与球面相交：球心为$P_c$，半径为r，解方程$||P(t)-P_c||-r=0$即可。（注意解要是正实数）

- 与隐式表面相交：如果生成图像的方程为$f(p)=0$，则将$P(t)$代入计算。

- 与平面相交：平面被平面上一点p'和法向量N表示：平面上任意一点p有：$(p-p')\cdot N=0$。将$P(t)$代入p即可。

- 与三角网格相交：有多种方法。主要步骤为：

  1. 计算射线和三角形平面的交点
  2. 将交点投影到平面上
  3. 判断交点是否在三角形内部

  可以使用质心坐标。对于三角形三个顶点$P_0,P_1,P_2$，有$P=\alpha P_0+\beta P_1+\gamma P_2$，其中$\alpha+\beta+\gamma=1$。将$\alpha$用其它两个符号代替，则相交公式为：
  
  $R_0+tR_d=(1-\beta-\gamma)P_0+\beta P_1+\gamma P_2$
  
  写成向量相乘形式：

$$
\begin{array}{}
(R_d & P_0-P_1 & P_0-P_2)
\end{array}
\begin{pmatrix}{}
t\\\beta\\\gamma
\end{pmatrix}=P_0-R_0
$$

通过求解该线性方程组，可以求出质心坐标和距离t。

设$E_1=P_0-P_1,E_2=P_0-P_2,S=P_0-R_0$，依据克莱姆法则 Cramer's rule，有：
$$
\begin{pmatrix}{}
t\\\beta\\\gamma
\end{pmatrix}=\frac{1}{\det(d,E_1,E_2)}
\begin{pmatrix}{}
\det(S,E_1,E_2)\\
\det(d,S,E_2)\\
\det(d,E_1,S)
\end{pmatrix}
$$
检查$\alpha, \beta,\gamma$是否在[0,1]内即可。

### 11.3 包围盒

判断光线和表面相交实在太慢了，需要要找近似来简化。

包围盒（边界体Bounding Volumes/ Box）：用一个盒状方形将物体包围，在测试射线与物体相交时，我们首先测试射线与边界盒相交，如果没有相交，那么射线肯定不会与物体相交，从而不计算内部物体是否与光线相交。

Haines提出了一种基于平板的箱体交叉测试方法：一个平板slab就是两个平行的平面planes，为了更快的计算而将它们分组。包围盒是三个平板围成的空间。通常平板和轴平面平行，称为轴对齐包围盒（Axis-Aligned Bounding Box, AABB）。当光线进入所有平板之间，说明光线进入包围盒。如果光线出了一个平板则说明光线出了包围盒。对光线表示的t进行调参，每个平板都会得到两个交点，分别是$t_\min$和$t_\max$。对于整个3D包围盒来说，有：$t_{enter}=\max(t_\min), t_{exit}=min(t_\max)$。若$t_{enter}<t_{exit}$则说明光线进入了包围盒。

需要注意的是，光线不是直线而是射线。如果$t_{exit}<0$，则说明碰撞盒在光线后面，没有交集。如果$t_{exit}\geq 0, t_{enter}<0$，则光源就在包围盒内，有交集。总之，有交集的判断条件为：
$$
(t_{enter}<t_{exit})\and(t_{exit}\geq0)
$$
包围盒技术的应用：

#### 11.3.1 统一空间划分(网格)Uniform Spatial Partitions (Grids)

1. 找到包围盒
2. 将包围盒内的空间均分成多个小块，每块是一个网格Grid
3. 如果包围盒内的物体和某个网格相交，则记录下来
4. 网格检测与光线相交，如果网格存储了物体则检验和物体相交。需要注意的是，不需要检测所有网格。如果某个网格与光线相交，下一个必然与其相邻。按光线通过次序依次检测即可

网格过多或过少效果都不好，启发式算法：网格数 = C * 包围盒内物体数。3D中，C一般取27。

在空旷的大场景中效果不好，需要在物体密集处网格更细，物体稀疏处网格更少。

#### 11.3.2 空间划分Spatial Partitions

Oct树、KD树、BSP树等等。KD-Trees每次把当前空间用一个平面均分，平面往往平行于某个轴平面。中间节点没有物体存储，只存储平面。物体都在叶子节点。相当于每个面都划出两个包围盒

#### 11.3.3 物体划分/包围盒分层BVH

一开始将很多物体用大包围盒围住，由在大包围盒内划出更小的包围盒，每个包围部分物体。由大到小可以建一棵树。启发式划分节点：选择节点中最长的轴，在中点处划分。当包围盒中只包含某个值以下个数的物体则停止。中间节点存储当前包围盒和子节点信息，叶子节点存储当前包围盒和其中的物体。

| 类型     | 划分方式                                       | 重叠                         |
| -------- | ---------------------------------------------- | ---------------------------- |
| 空间划分 | 将空间划分成没有交集的子空间                   | 一个物体可能被多个子空间包含 |
| 物体划分 | 将物体集划分成几个子集，每个集合有自己的包围盒 | 不同的包围盒可能会重叠       |

------------

## 十二、 曲线和曲面建模

### 12.1 补差与近似

- 插值interpolation：曲线会通过所有控制点时
- 近似approximation：控制点只控制曲线方向，曲线不通过控制点

#### 12.1.1 差值

如果给定一系列离散点$(x_0,y_0),(x_1,y_1)...(x_n,y_n)$：

- 最简单的插值方法是定位最近的数据值，并分配相同的值。
- 线性差值：对于特定x的任意一点$(x,y)$，找到左右最x值近的点$(x_a,y_a)$和$(x_b,y_b)$，有：$y=y_a+(y_b-y_a)\frac{x-x_a}{x_b-x_a}$，看上去就是各个离散点之间用直线连接。
  - 数据误差为0
  - 函数性质不好：不光滑
- 多项式差值：用高次多项式来待定系数并代入值
  - 理论误差为0
  - 可能被较差的数据带歪，比如噪声，导致函数性质不好，预测不可靠

#### 12.1.2 近似

逼近拟合函数，数据误差不为0但是足够小。最小二乘法公式：最小化损失$E=\sum^n_{i=1}(f(x_i)-y_i)^2$。用直线近似，当系数矩阵的列数为2时，多数情况下可以存在近似解：
$$
\begin{bmatrix}
x_1 & 1\\
x_2 & 1\\
...\\
x_n & 1\\
\end{bmatrix}
\begin{bmatrix}
k\\b
\end{bmatrix}=
\begin{bmatrix}
y_1\\y_2\\...\\y_n
\end{bmatrix}
$$
当原始数据过于复杂时，最小二乘法并不足够好。更普遍的情况是，计算k次多项式系数：
$$
f(x)=a_0+a_1x+...+a_kx^k
$$
使得损失最小。上述公式称为最小二乘曲线。
$$
\begin{bmatrix}
1 & x_1 & x_1^2 & ... & x_1^k\\
1 & x_2 & x_2^2 & ... & x_2^k\\
...\\
1 & x_n & x_n^2 & ... & x_n^k\\
\end{bmatrix}
\begin{bmatrix}
a_0\\a_1\\...\\a_n
\end{bmatrix}=
\begin{bmatrix}
y_1\\y_2\\...\\y_n
\end{bmatrix}
$$
求解：等式两边同乘含有$x$的那个矩阵的转置。当各个x互不相等且 n>k ，总能找到唯一解。

拟合函数的好坏是应用驱动的。没有绝对的好坏之分。

### 12.2 曲线表示

- 显式表示，如$y=x^2+5x+3$。不能表示所有曲线
- 隐式表示，如$(x-a)^2+(y-b)^2=r^2$。二维下总能表述成$f(x,y)=0$。三维曲线不容易用隐式形式表示，我们可以把曲线表示成两个曲面的交点：$f(x,y,z)=g(x,y,z)=0$
- 参数表示：$x=x(t),y=y(t)$。
  - 容易推广到高维
  - 能更自由地控制曲线和曲面的形状
  - 更容易处理无限斜率的情况
  - 用向量和矩阵表示几何分量，简化了计算
  - 难以分辨内外
  - 难以判断点在曲面或曲线上
  - 难以表述复杂的曲线和曲面，如分段的表面

### 12.3 样条spline和三次埃尔米特样条插值

样条指通过一组给定点集来生成平滑曲线的柔性带。

#### 三次埃尔米特样条插值Cubic Hermite spline interpolation

数据应该包含所需的函数值和每个x处的导数。如果只有数值则还需要估计导数。埃米尔特曲线通过给定曲线的两个端点的位置矢量以及切线矢量来描述曲线。

三次曲线$p(t)=at^3+bt^2+ct+d$有：

- $P(0)=h_0=d$
- $P(1)=h_1=a+b+c+d$
- $P'(0)=h_2=c$
- $P'(1)=h_3=3a+2b+c$

矩阵表述为：
$$
\begin{bmatrix}
h_0\\h_1\\h_2\\h_3
\end{bmatrix}=
\begin{bmatrix}
0 & 0 & 0 & 1\\
1 & 1 & 1 & 1\\
0 & 0 & 1 & 0\\
3 & 2 & 1 & 0\\
\end{bmatrix}
\begin{bmatrix}
a\\b\\c\\d
\end{bmatrix}
$$
即：
$$
\begin{bmatrix}
a\\b\\c\\d
\end{bmatrix}=
\begin{bmatrix}
2 & -2 & 1 & 1\\
-3 & 3 & -2 & -1\\
0 & 0 & 1 & 0\\
1 & 0 & 0 & 0\\
\end{bmatrix}
\begin{bmatrix}
h_0\\h_1\\h_2\\h_3
\end{bmatrix}
$$
又有：
$$
P(t)=
\begin{bmatrix}
a & b & c &d
\end{bmatrix}
\begin{bmatrix}
t^3\\t^2\\t\\1
\end{bmatrix}
$$
求得：
$$
\begin{bmatrix}
H_0(t)\\H_1(t)\\H_2(t)\\H_3(t)
\end{bmatrix}=
\begin{bmatrix}
2 & -3 & 0 & 1\\
-2 & 3 & 0 & 0\\
1 & -2 & 1 & 0\\
1 & -1 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
t^3\\t^2\\t\\1
\end{bmatrix}
$$

$$
P(t)=\sum_{i=0}^3h_iH_i(t)
$$

### 12.4 bezier曲线

贝赛尔曲线直观地展示给定条件与曲线形状之间的关系，用户可以通过修改参数方便地改变曲线的形状和顺序。本质是由调和函数根据控制点差值生成的，参数方程为：
$$
Q(t)=\sum^n_{i=0}P_iB_{i,n}(t),t\in[0,1]
$$
该式子为n次多项式，有n+1项。其中$P_i$表示特征多边形的n+1个顶点向量，$B_{i,n}(t)$为伯恩斯坦Bernstein函数，表示为：
$$
B_{i,n}(t)=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,...,n
$$
二次贝塞尔曲线含有三个控制点，参数n为2。三次的则含有四个控制点。根据Bernstein多项式构成了三次Bézier曲线的一组基，或称为三次Bézier 曲线的调和函数，即：
$$
\left\{\begin{array}{}
B_{0,3}(t)=(1-t)^3\\
B_{1,3}(t)=3t(1-t)^2\\
B_{2,3}(t)=3t^2(1-t)\\
B_{3,3}(t)=t^3
\end{array}\right.
$$
贝塞尔曲线的性质：

- 端点性质：贝叶斯曲线通过特征多边形的起点和终点
- 对称性：将控制点的顺颠倒，新曲线形状不变，参数的变化方向相反
- 凸包性：贝叶斯曲线一定落在其控制多边形的凸包中

- 仿射不变性：曲线形状不随坐标的变换而变化，形状只与顶点的相对位置有关。因此对曲线进行几何变换时只需要对控制点进行仿射变换，然后重新绘制曲线
- 全局性：当单个控制点移动时，整个形状会改变

控制点决定曲线的度数，控制点多，度数高，高维的曲线难以控制，考虑分段贝塞尔曲线。但分段又容易导致曲线不连续

### 12.5 B样条B-Spline曲线

为了解决贝塞尔曲线的控制点多则度数高以及全局性的问题。

考虑将曲线分段但又要有统一的表达方式。B样条曲线是分段多项式曲线给出了n+1个控制点，节点向量knot vector是一串非递减的实数序列$\bold t=[t_0,t_1,...,t_{n+k}]$。k阶order的（或者称为k-1次的degree）控制点定义为：
$$
\bold P(u)=\sum^n_{i=0}N_{i,k}(t)\cdot\bold d_i
$$
$N_{i,k}(t)$定义为：
$$
\left\{
\begin{array}{}
N_{i,0}=
\left\{\begin{array}{}
1 & t_1\leq t<t_{i+1}\\
0 & Others
\end{array}\right.\\
N_{i,k}(t)=\frac{t-t_i}{t_{i+k}-t_i}N_{i,k-1}(t)+\frac{t_{i+k+1}-t}{t_{i+k+1}-t_{i+1}}N_{i+1,k-1}(t)\\
\frac{0}{0}=0
\end{array}
\right.
$$



- 局部性
- 连续性
- 凸包性
- 变差缩减性：一条直线不会交曲线的次数多余交曲线控制多边形的次数
- 集合不变性：不同的坐标系下形状和位置不变
- 仿射不变性
- 直线保持性：控制多边形的点共线则曲线是直线
- 灵活性：可以容易地表述线段、尖点、切线等

### 12.6 Bezier曲面

曲面一般不通过中心控制点，而是向控制点“拉伸”，仿佛每一个点都产生吸引力。

贝塞尔曲面可以用张量积或单纯形(三角形)来构造：
$$
\bold f(u,v)=\sum^n_{i=1}\sum^n_{j=1}b_i(u)b_j(v)\bold p_{i,j}
$$
